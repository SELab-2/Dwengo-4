
=== ./dwengoAPI.ts ===
import axios, { AxiosInstance } from "axios";

export const dwengoAPI: AxiosInstance = axios.create({
  baseURL: process.env.DWENGO_BASE_URL || "https://dwengo.org/backend",
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
  timeout: 5000,
});

=== ./assignmentController.ts ===
import { Request, Response } from "express";
import assignmentService from "../services/assignmentService";

export class AssignmentController {
  async getAssignmentsById(req: Request, res: Response): Promise<void> {
    try {
      if (!req.params.assignmentId || isNaN(parseInt(req.params.assignmentId))) {
        res.status(400).json({ error: "Invalid assignment ID" });
        return;
      }
      const assignmentId: number = parseInt(req.params.assignmentId);
      const assignment = await assignmentService.getAssignmentById(assignmentId);
      res.status(200).json(assignment);
    } catch (error) {
      res.status(500).json({ error: "Failed to retrieve assignment" });
    }
  }
}




=== ./joinrequest/joinRequestController.ts ===
import { Request, Response } from "express";
import joinRequestService from "../../services/joinRequestService";
import { JoinRequest } from "@prisma/client";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import { AppError } from "../../errors/errors";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";

// Higher-order function to handle errors and reduce duplication
const handleRequest = (handler: (req: Request, res: Response) => Promise<void>) =>
    async (req: Request, res: Response): Promise<void> => {
        try {
            await handler(req, res);
        } catch (error) {
            const message: string = error instanceof Error ? error.message : "An unknown error occurred";
            res.status(error instanceof AppError ? error.statusCode : 400).json({ error: message });
        }
    };


/**
 * Creates a join request for a student to join a class (class code in request body)
 * @route POST /student/classes/join
 * returns the created join request in the response body
 */
export const createJoinRequest = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const joinCode = req.body.joinCode || req.query.joinCode as string;
    const studentId: number = getUserFromAuthRequest(req).id;
    const joinRequest: JoinRequest | undefined = await joinRequestService.createValidJoinRequest(studentId, joinCode);
    res.status(201).json({ joinRequest });
});

/**
 * Updates the status of a join request (approve or deny)
 * @route PATCH /teacher/classes/:classId/join-requests/:requestId
 * @param classId - id of the class for which the join request was sent
 * @param requestId - id of the join request to be updated
 * returns the updated join request in the response body
 */
export const updateJoinRequestStatus = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const requestId: number = parseInt(req.params.requestId);
    const { action }: { action: string } = req.body; // 'approve' or 'deny' from the request body
    const teacherId: number = getUserFromAuthRequest(req).id;

    if (!action || (action !== 'approve' && action !== 'deny')) {
        res.status(400).json({ error: "Action must be 'approve' or 'deny'" });
    }

    if (action === 'approve') {
        const joinRequest: JoinRequest = await joinRequestService.approveRequestAndAddStudentToClass(requestId, teacherId, classId);
        res.status(200).json({ joinRequest, message: "Join request approved." });
    } else if (action === 'deny') {
        const joinRequest: JoinRequest = await joinRequestService.denyJoinRequest(requestId, teacherId, classId);
        res.status(200).json({ joinRequest, message: "Join request denied." });
    }
});

/**
 * @route GET /teacher/classes/:classId/join-requests
 * @param classId - id of the class for which the join requests are fetched
 * returns a list of all join requests for the class in the response body
 */
export const getJoinRequestsByClass = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const teacherId: number = getUserFromAuthRequest(req).id;
    const joinRequests: JoinRequest[] = await joinRequestService.getJoinRequestsByClass(teacherId, classId);
    res.status(200).json({ joinRequests });
});

=== ./learningObject/learningObjectController.ts ===
import { Request, Response } from "express";
import {
  getAllLearningObjects,
  getLearningObjectById,
  searchLearningObjects,
  getLearningObjectsForPath,
  // [NIEUW] importeer de nieuwe service-functie:
  getLearningObjectByHruidLangVersion,
} from "../../services/combinedLearningObjectService";
import { LearningObjectDto } from "../../services/dwengoLearningObjectService";

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    role: string;
  };
}

function userIsTeacherOrAdmin(req: AuthenticatedRequest): boolean {
  const role: string | undefined = req.user?.role;
  return role === "TEACHER" || role === "ADMIN";
}

// Haal alle leerobjecten (Dwengo + lokaal)
export const getAllLearningObjectsController = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const isTeacher: boolean = userIsTeacherOrAdmin(req);
    const objects: LearningObjectDto[] = await getAllLearningObjects(isTeacher);
    res.json(objects);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij ophalen leerobjecten (combi Dwengo + local)" });
  }
};

// Haal één leerobject op (via :id)
export const getLearningObjectController = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const { id } = req.params;
    const isTeacher: boolean = userIsTeacherOrAdmin(req);
    const lo: LearningObjectDto | null = await getLearningObjectById(id, isTeacher);
    if (!lo) {
      res.status(404).json({ error: "Leerobject niet gevonden of geen toegang" });
      return;
    }
    res.json(lo);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij ophalen leerobject (combi Dwengo + local)" });
  }
};

// Zoeken naar leerobjecten (Dwengo + lokaal)
export const searchLearningObjectsController = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const searchTerm: string = req.query.q?.toString() || "";
    const isTeacher: boolean = userIsTeacherOrAdmin(req);
    const results: LearningObjectDto[] = await searchLearningObjects(isTeacher, searchTerm);
    res.json(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij zoeken naar leerobjecten (combi Dwengo + local)" });
  }
};

// Haal alle leerobjecten op die horen bij een specifiek leerpad (op basis van pathId)
export const getLearningObjectsForPathController = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const { pathId } = req.params;
    const isTeacher: boolean = userIsTeacherOrAdmin(req);
    const objects: LearningObjectDto[] = await getLearningObjectsForPath(pathId, isTeacher);
    res.json(objects);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij ophalen leerobjecten voor leerpad (Dwengo)" });
  }
};

// [NIEUW] Haal één leerobject op basis van hruid + language + version
export const getLearningObjectByHruidLangVersionController = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  
  try {
    const { hruid, language, version } = req.query;
    if (!hruid || !language || !version) {
      res.status(400).json({
        error: "Geef hruid, language en version op als queryparameters, bv. ?hruid=xxx&language=nl&version=2",
      });
      return;
    }

    const isTeacher: boolean = userIsTeacherOrAdmin(req);
    const verNum = parseInt(version.toString(), 10);
    if (isNaN(verNum)) {
      res.status(400).json({ error: "Version moet een getal zijn." });
      return;
    }

    // Servicecall
    const lo = await getLearningObjectByHruidLangVersion(
      hruid.toString(),
      language.toString(),
      verNum,
      isTeacher
    );

    if (!lo) {
      res.status(404).json({
        error: "Geen leerobject gevonden (of je hebt geen toegang) met deze hruid-language-version",
      });
      return;
    }

    res.json(lo);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij ophalen leerobject op basis van hruid-language-version" });
  }
};

=== ./learningPath/learningPathController.ts ===
import { Request, Response } from "express";
import { searchLearningPaths, getLearningPathByIdOrHruid, LearningPathDto } from "../../services/learningPathService";

interface LearningPathFilters {
  language?: string;
  hruid?: string;
  title?: string;
  description?: string;
  all?: string;
}

/**
 * Zoekt leerpaden via Dwengo-API.
 * Mogelijke queryparams:
 *  ?language=nl
 *  ?hruid=...
 *  ?title=...
 *  ?description=...
 *  ?all=  (leeg om alles op te halen)
 */
export const searchLearningPathsController = async (req: Request, res: Response): Promise<void> => {
  try {
    const filters: LearningPathFilters = {
      language: req.query.language?.toString(),
      hruid: req.query.hruid?.toString(),
      title: req.query.title?.toString(),
      description: req.query.description?.toString(),
      all: req.query.all?.toString(),
    };

    const results: LearningPathDto[] = await searchLearningPaths(filters);
    res.json(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij zoeken naar leerpaden" });
  }
};

/**
 * Haalt 1 leerpad op (op basis van _id of hruid).
 * We gebruiken de service getLearningPathByIdOrHruid voor 'idOrHruid'
 */
export const getLearningPathByIdController = async (req: Request, res: Response): Promise<void> => {
  try {
    const { pathId } = req.params; // pathId is een string
    const path: LearningPathDto | null = await getLearningPathByIdOrHruid(pathId);

    if (!path) {
      res.status(404).json({ error: "Leerpad niet gevonden" });
      return;
    }

    res.json(path);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "Fout bij ophalen leerpad" });
  }
};

=== ./question/questionController.ts ===
// controllers/question/questionController.ts
import { Response } from "express";
import QuestionService from "../../services/questionsService";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";

// Hulp-functie om errors te uniformiseren
const handleRequest = (
  handler: (req: AuthenticatedRequest, res: Response) => Promise<void>
) => async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    await handler(req, res);
  } catch (error) {
    const message: string =
      error instanceof Error ? error.message : "An unknown error occurred";
    res.status(400).json({ error: message });
    return;
  }
};

/**
 * createQuestionGeneral
 *  Verwacht in de route:
 *    POST /question/general/:assignmentId
 *  In de body:
 *  {
 *    title, text, teamId,
 *    pathRef, isExternal
 *  }
 */
export const createQuestionGeneral = handleRequest(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { assignmentId } = req.params; // we gebruiken learningPathId niet meer in param, want we hebben pathRef in de body
    const { title, text, teamId, pathRef, isExternal } = req.body;
    const studentId = getUserFromAuthRequest(req).id;

    if (!studentId) {
      res.status(400).json({ error: "Student ID is required" });
      return;
    }
    if (!assignmentId) {
      res.status(400).json({ error: "Missing assignmentId param" });
      return;
    }
    if (!pathRef) {
      res.status(400).json({ error: "Missing pathRef in body" });
      return;
    }

    const questionGeneral = await QuestionService.createQuestionGeneral(
      Number(assignmentId),
      title,
      text,
      teamId,
      studentId,
      "GENERAL",
      pathRef,
      !!isExternal
    );
    res.status(201).json(questionGeneral);
  }
);

/**
 * createQuestionSpecific
 *  Verwacht in de route:
 *    POST /question/specific/:assignmentId
 *  In de body:
 *  {
 *    title, text, teamId,
 *    objectRef, isExternal,
 *    learningPathId (optioneel, als je die logica wil)
 *  }
 */
export const createQuestionSpecific = handleRequest(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { assignmentId } = req.params; // i.p.v. learningPathId, etc. In de body kan je dat ook meesturen
    const {
      title,
      text,
      teamId,
      objectRef,
      isExternal,
      learningPathId,
    } = req.body;
    const studentId = getUserFromAuthRequest(req).id;

    if (studentId === undefined) {
      res.status(400).json({ error: "Student ID is required" });
      return;
    }
    if (!assignmentId) {
      res.status(400).json({ error: "Missing assignmentId param" });
      return;
    }
    if (!objectRef) {
      res.status(400).json({ error: "Missing objectRef in body" });
      return;
    }

    // Let op: we willen misschien wel learningPathId checken (optioneel).
    // Is up to you of je dat in param of body zet.
    const questionSpecific = await QuestionService.createQuestionSpecific(
      Number(assignmentId),
      title,
      text,
      teamId,
      studentId,
      "SPECIFIC",
      objectRef,
      isExternal,
      learningPathId || ""
    );
    res.status(201).json(questionSpecific);
  }
);

export const createQuestionMessage = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId } = req.params;
    const { text } = req.body;
    const userId = getUserFromAuthRequest(req).id;
    if (userId === undefined) {
        res.status(400).json({ error: "Student ID is required" });
        return;
    }
    const questionMessage = await QuestionService.createQuestionMessage(Number(questionId), text, Number(userId));
    res.status(201).json(questionMessage);
});

export const updateQuestion = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId } = req.params;
    const { title } = req.body;
    const question = await QuestionService.updateQuestion(Number(questionId), title);
    res.status(201).json(question);
});

export const updateQuestionMessage = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId, questionMessageId } = req.params;
    const { text } = req.body;
    const userId = getUserFromAuthRequest(req).id;
    if (userId === undefined) {
        res.status(400).json({ error: "Student ID is required" });
        return;
    }
    const questionMessage = await QuestionService.updateQuestionMessage(Number(questionId), Number(questionMessageId), text, userId);
    res.status(201).json(questionMessage);
});

export const getQuestion = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId } = req.params;
    const question = await QuestionService.getQuestion(Number(questionId));
    res.status(200).json(question);
});

export const getQuestionsTeam = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { teamId } = req.params;
    const questions = await QuestionService.getQuestionsTeam(Number(teamId));
    res.status(200).json(questions);
});

export const getQuestionsClass = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { classId } = req.params;
    const questions = await QuestionService.getQuestionsClass(Number(classId));
    res.status(200).json(questions);
});

export const getQuestionsAssignment = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { assignmentId, classId } = req.params;
    const questions = await QuestionService.getQuestionsAssignment(Number(assignmentId), Number(classId));
    res.status(200).json(questions);
});

export const getQuestionMessages = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId } = req.params;
    const messages = await QuestionService.getQuestionMessages(Number(questionId));
    res.status(200).json(messages);
});

export const deleteQuestion = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId } = req.params;
    await QuestionService.deleteQuestion(Number(questionId));
    res.status(204).end();
});

export const deleteQuestionMessage = handleRequest(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { questionId, questionMessageId } = req.params;
    await QuestionService.deleteQuestionMessage(Number(questionId), Number(questionMessageId));
    res.status(204).end();
});


=== ./student/studentAssignmentController.ts ===
import { Response } from "express";
import { getAssignmentsForStudent } from "../../services/studentAssignmentService";
import { Assignment } from "@prisma/client";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";

const allowedSortFields = ["deadline", "createdAt", "updatedAt"];

function extractSortableFields(input: string): string[] {
  return (
    input?.split(",").filter((field) => allowedSortFields.includes(field)) || [
      "deadline",
    ]
  );
}

export const getStudentAssignments = async (
  req: AuthenticatedRequest,
  res: Response
): Promise<void> => {
  try {
    const studentId: number = getUserFromAuthRequest(req).id;

    const sortFields: string[] = extractSortableFields(req.query.sort as string);
    const order: "desc" | "asc" = req.query.order === "desc" ? "desc" : "asc";
    const limit: number = Number(req.query.limit) || 5;

    if (isNaN(limit) || limit <= 0) {
      res.status(400).json({ error: "Limit wasn't a valid number" });
      return;
    }

    const assignments: Assignment[] = await getAssignmentsForStudent(
      studentId,
      sortFields,
      order,
      limit
    );
    res.status(200).json(assignments);
  } catch (error) {
    res
      .status(500)
      .json({ error: "Something went wrong while requesting the assignments" });
  }
};

=== ./student/studentAuthController.ts ===
import { PrismaClient } from '@prisma/client';
import asyncHandler from 'express-async-handler';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { Request, Response } from 'express';

const prisma = new PrismaClient();

// Functie om een JWT-token te genereren
const generateToken = (id: number | string): string => {
  if (!process.env.JWT_SECRET) {
    throw new Error("JWT_SECRET is niet gedefinieerd in de omgevingsvariabelen");
  }
  return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: "7d" });
};

interface RegisterStudentBody {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

// @desc    Registreer een nieuwe leerling
// @route   POST /student/auth/register
// @access  Public
export const registerStudent = asyncHandler(async (req: Request, res: Response) => {
  const { firstName, lastName, email, password } = req.body as RegisterStudentBody;

  // Controleer of alle velden ingevuld zijn
  if (!firstName || !lastName || !email || !password) {
    res.status(400);
    throw new Error("Vul alle velden in");
  }

  // Basisvalidatie voor e-mail
  if (!/\S+@\S+\.\S+/.test(email)) {
    res.status(400);
    throw new Error("Voer een geldig e-mailadres in");
  }

  // Controleer of het wachtwoord lang genoeg is
  if (password.length < 6) {
    res.status(400);
    throw new Error("Het wachtwoord moet minstens 6 karakters lang zijn");
  }

  // Controleer of er al een gebruiker bestaat met dit e-mailadres
  const existingUser = await prisma.user.findUnique({ where: { email } });
  if (existingUser) {
    res.status(400);
    throw new Error("Gebruiker bestaat al");
  }

  // Hash het wachtwoord
  const hashedPassword = await bcrypt.hash(password, 10);

  // Maak eerst een User-record aan met role "STUDENT"
  const newUser = await prisma.user.create({
    data: {
      firstName,
      lastName,
      email,
      password: hashedPassword,
      role: "STUDENT",
    },
  });

  // Maak vervolgens het gekoppelde Student-record
  await prisma.student.create({
    data: {
      userId: newUser.id,
    },
  });

  res.status(201).json({ message: "Leerling succesvol geregistreerd" });
});

interface LoginStudentBody {
  email: string;
  password: string;
}

// @desc    Inloggen van een leerling
// @route   POST /student/auth/login
// @access  Public
export const loginStudent = asyncHandler(async (req: Request, res: Response) => {
  const { email, password } = req.body as LoginStudentBody;

  // Basisvalidatie voor e-mail
  if (!/\S+@\S+\.\S+/.test(email)) {
    res.status(400);
    throw new Error("Voer een geldig e-mailadres in");
  }

  // Zoek eerst de gebruiker
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user || user.role !== "STUDENT") {
    res.status(401);
    throw new Error("Ongeldige gebruiker");
  }

  // Haal het gekoppelde Student-record op
  const student = await prisma.student.findUnique({
    where: { userId: user.id },
    include: { user: true },
  });

  if (!student || !student.user) {
    res.status(401);
    throw new Error("Ongeldige gebruiker");
  }

  // Vergelijk het opgegeven wachtwoord met de opgeslagen hash
  const passwordMatches = await bcrypt.compare(password, student.user.password);
  if (!passwordMatches) {
    res.status(401);
    throw new Error("Ongeldig wachtwoord");
  }

  res.json({
    message: "Succesvol ingelogd",
    token: generateToken(student.userId),
  });
});

=== ./student/studentClassController.ts ===
import { Request, Response } from 'express';

const asyncHandler = require("express-async-handler");
import classService from "../../services/classService";

// kan een student al een overzicht van al de klassen dat die in zit zien? zoniet zou dit hier moeten komen

=== ./teacher/feedbackController.ts ===
import { Response } from "express";
import service from "../../services/feedbackService";
import { Feedback } from "@prisma/client";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";

export default class FeedbackController {
    static async getAllFeedbackForEvaluation(req: AuthenticatedRequest, res: Response) {
        try {
            const { assignmentId, evaluationId } = req.params;
            const teacherId: number = Number(req.user?.id);

            const feedback: Feedback[] = await service.getAllFeedbackForEvaluation(Number(assignmentId), evaluationId, teacherId);
            res.json(feedback);
        } catch (error) {
            res.status(500).json({ error: "Failed to retrieve feedback" });
        }
    }

    static async createFeedback(req: AuthenticatedRequest, res: Response) {
        try {
            const teacherId: number | undefined = req.user?.id;
            // TODO Is dit sowieso defined of hoe ga ik hier het beste met de undefined om?

            const { submissionId, description }: {
                submissionId: number,
                description: string
            } = req.body;

            const feedback: Feedback = await service.createFeedback(submissionId, Number(teacherId), description);
            res.status(201).json(feedback);
        } catch (error) {
            res.status(500).json({ error: "Failed to create feedback" });
        }

    }

    static async getFeedbackForSubmission(req: AuthenticatedRequest, res: Response) {
        try {
            const submissionId: number = Number(req.params.submissionId);
            const teacherId: number = Number(req.user?.id);

            const feedback: Feedback | null = await service.getFeedbackForSubmission(submissionId, teacherId);
            if (feedback) {
                res.json(feedback);
            } else {
                res.status(404).json({ error: "Feedback not found" });
            }
        } catch (error) {
            res.status(500).json({ error: "Failed to retrieve feedback" });
        }

    }

    static async updateFeedbackForSubmission(req: AuthenticatedRequest, res: Response) {
        try {
            const submissionId: number = Number(req.params.submissionId);
            const teacherId: number = Number(req.user?.id);

            const { description }: { description: string } = req.body;
            const feedback: Feedback = await service.updateFeedbackForSubmission(submissionId, description, teacherId);
            res.json(feedback)
        } catch (error) {
            res.status(500).json({ error: "Failed to update feedback" });
        }
    }

    static async deleteFeedbackForSubmission(req: AuthenticatedRequest, res: Response) {
        try {
            const submissionId: number = Number(req.params.submissionId);
            const teacherId: number = Number(req.user?.id);

            await service.deleteFeedbackForSubmission(submissionId, teacherId);
            res.json({ message: "Feedback deleted" });
        } catch (error) {
            res.status(500).json({ error: "Failed to delete feedback" });
        }
    }
}

=== ./teacher/inviteController.ts ===
import { Response } from "express";
import asyncHandler from 'express-async-handler';
import { Invite } from "@prisma/client";
import inviteService from "../../services/inviteService";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";

/**
 * Create an invite for a teacher to join a class
 * @route POST /teacher/classes/:classId/invites
 * @param classId - id of the class to which the teacher is getting invited
 * returns the created invite in the response body
 */
export const createInvite = asyncHandler(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const { otherTeacherId }: { otherTeacherId: number } = req.body;
    const classTeacherId: number = getUserFromAuthRequest(req).id;

    const invite: Invite = await inviteService.createInvite(classTeacherId, otherTeacherId, classId);
    res.status(201).json({ invite });
}); 


/**
 * Get all pending invites for a class
 * @route GET /teacher/classes/:classId/invites
 * @param classId - id of the class for which the invites are fetched
 * returns a list of all invites for the class in the response body
 */
export const getPendingInvitesForClass = asyncHandler(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const classTeacherId: number = getUserFromAuthRequest(req).id;

    const invites: Invite[] = await inviteService.getPendingInvitesForClass(classTeacherId, classId);
    res.status(200).json({ invites });
});


/**
 * Get all pending invites for a teacher
 * @route GET /teacher/classes/invites
 * returns a list of all invites for the teacher in the response body
 */
export const getPendingInvitesForTeacher = asyncHandler(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const teacherId: number = getUserFromAuthRequest(req).id;

    const invites: Invite[] = await inviteService.getPendingInvitesForTeacher(teacherId);
    res.status(200).json({ invites });
});


/**
 * Update the status of an invite
 * @route PATCH /teacher/classes/invites/:inviteId
 * @param inviteId - id of the invite to be updated
 * returns the updated invite in the response body
 */
export const updateInviteStatus = asyncHandler(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const inviteId: number = parseInt(req.params.inviteId);
    const { action }: { action: string } = req.body;
    const teacherId: number = getUserFromAuthRequest(req).id;

    if (action == "accept") {
        const invite: Invite = await inviteService.acceptInviteAndJoinClass(teacherId, inviteId);
        res.status(200).json({ invite });
    } else if (action == "decline") {
        const invite: Invite = await inviteService.declineInvite(teacherId, inviteId);
        res.status(200).json({ invite });
    } else {
        res.status(400).json({ error: "Action must be 'accept' or 'decline'" });
    }
});


/**
 * Delete an invite
 * @route DELETE /teacher/classes/:classId/invites/:inviteId
 * @param classId - id of the class for which the invite is deleted 
 * @param inviteId - id of the invite to be deleted
 * returns the deleted invite in the response body
 * 
 * Any teacher of the class can delete the invite (not just the teacher who created the invite).
 */
export const deleteInvite = asyncHandler(async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const inviteId: number = parseInt(req.params.inviteId);
    const classId: number = parseInt(req.params.classId);
    const classTeacherId: number = getUserFromAuthRequest(req).id;

    const invite: Invite = await inviteService.deleteInvite(classTeacherId, inviteId, classId);
    res.status(200).json({ invite: invite, message: "invite was succesfully deleted" });
});

=== ./teacher/teacherAssignmentController.ts ===
import { Response } from "express";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import teacherAssignmentService from "../../services/teacherServices/teacherAssignmentService";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";

export class AssignmentTeacherController {
  createAssignmentForClass = async (
    req: AuthenticatedRequest,
    res: Response
  ): Promise<void> => {
    try {
      const teacherId: number = getUserFromAuthRequest(req).id;
      const {
        classId,
        pathRef, 
        isExternal,
        deadline,
      }: { 
        classId: number; 
        pathRef: string; 
        isExternal: boolean; 
        deadline: string 
      } = req.body;

      const parsedDeadline = new Date(deadline);

      const assignment = await teacherAssignmentService.createAssignmentForClass(
        teacherId,
        classId,
        pathRef,
        isExternal,
        parsedDeadline
      );
      res.status(201).json(assignment);
    } catch (error) {
      res.status(500).json({ error: "Failed to create assignment" });
    }
  };

  getAssignmentsByClass = async (
    req: AuthenticatedRequest,
    res: Response
  ): Promise<void> => {
    try {
      const classId: number = parseInt(req.params.classId);
      const teacherId: number = getUserFromAuthRequest(req).id;
      const assignments = await teacherAssignmentService.getAssignmentsByClass(
        classId,
        teacherId
      );
      res.status(200).json(assignments);
    } catch (error) {
      res.status(500).json({ error: "Failed to retrieve assignments" });
    }
  };

  updateAssignment = async (
    req: AuthenticatedRequest,
    res: Response
  ): Promise<void> => {
    try {
      const assignmentId: number = parseInt(req.params.assignmentId);
      const { pathRef, isExternal } = req.body; 
      const teacherId: number = getUserFromAuthRequest(req).id;

      const updatedAssignment = await teacherAssignmentService.updateAssignment(
        assignmentId,
        pathRef,
        isExternal,
        teacherId
      );
      res.json(updatedAssignment);
    } catch (error) {
      res.status(500).json({ error: "Failed to update assignment" });
    }
  };

  deleteAssignment = async (
    req: AuthenticatedRequest,
    res: Response
  ): Promise<void> => {
    try {
      const assignmentId: number = parseInt(req.params.assignmentId);
      const teacherId: number = getUserFromAuthRequest(req).id;
      await teacherAssignmentService.deleteAssignment(assignmentId, teacherId);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete assignment" });
    }
  };
}

=== ./teacher/teacherAuthController.ts ===
import { PrismaClient } from '@prisma/client';
import asyncHandler from 'express-async-handler';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { Request, Response } from 'express';

const prisma = new PrismaClient();

// Functie om een JWT-token te genereren
const generateToken = (id: number | string): string => {
  if (!process.env.JWT_SECRET) {
    throw new Error("JWT_SECRET is niet gedefinieerd in de omgevingsvariabelen");
  }
  return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: "7d" });
};

interface RegisterTeacherBody {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
}

// @desc    Registreer een nieuwe leerkracht
// @route   POST /teacher/auth/register
// @access  Public
export const registerTeacher = asyncHandler(async (req: Request, res: Response) => {
  const { firstName, lastName, email, password } = req.body as RegisterTeacherBody;

  // Controleer of alle velden ingevuld zijn
  if (!firstName || !lastName || !email || !password) {
    res.status(400);
    throw new Error("Vul alle velden in");
  }

  // Basisvalidatie voor e-mail
  if (!/\S+@\S+\.\S+/.test(email)) {
    res.status(400);
    throw new Error("Voer een geldig e-mailadres in");
  }

  // Controleer of het wachtwoord lang genoeg is
  if (password.length < 6) {
    res.status(400);
    throw new Error("Het wachtwoord moet minstens 6 karakters lang zijn");
  }

  // Controleer of er al een gebruiker bestaat met dit e-mailadres
  const existingUser = await prisma.user.findUnique({ where: { email } });
  if (existingUser) {
    res.status(400);
    throw new Error("Gebruiker bestaat al");
  }

  // Hash het wachtwoord
  const hashedPassword = await bcrypt.hash(password, 10);

  // Maak eerst een User-record aan met role "TEACHER"
  const newUser = await prisma.user.create({
    data: {
      firstName,
      lastName,
      email,
      password: hashedPassword,
      role: "TEACHER",
    },
  });

  // Maak vervolgens het gekoppelde Teacher-record
  await prisma.teacher.create({
    data: {
      userId: newUser.id,
    },
  });

  res.status(201).json({ message: "Leerkracht succesvol geregistreerd" });
});

interface LoginTeacherBody {
  email: string;
  password: string;
}

// @desc    Inloggen van een leerkracht
// @route   POST /teacher/auth/login
// @access  Public
export const loginTeacher = asyncHandler(async (req: Request, res: Response) => {
  const { email, password } = req.body as LoginTeacherBody;

  // Basisvalidatie voor e-mail
  if (!/\S+@\S+\.\S+/.test(email)) {
    res.status(400);
    throw new Error("Voer een geldig e-mailadres in");
  }

  // Zoek eerst de gebruiker
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user || user.role !== "TEACHER") {
    res.status(401);
    throw new Error("Ongeldige gebruiker");
  }

  // Haal het gekoppelde Teacher-record op
  const teacher = await prisma.teacher.findUnique({
    where: { userId: user.id },
    include: { user: true },
  });

  if (!teacher || !teacher.user) {
    res.status(401);
    throw new Error("Ongeldige gebruiker");
  }

  // Vergelijk het opgegeven wachtwoord met de opgeslagen hash
  const passwordMatches = await bcrypt.compare(password, teacher.user.password);
  if (!passwordMatches) {
    res.status(401);
    throw new Error("Ongeldig wachtwoord");
  }

  res.json({
    message: "Succesvol ingelogd",
    token: generateToken(teacher.userId),
  });
});

=== ./teacher/teacherClassController.ts ===
import asyncHandler from "express-async-handler";
import { Response } from "express";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import classService from "../../services/classService";
import { Student, User } from "@prisma/client";
import { getUserFromAuthRequest } from "../../helpers/getUserFromAuthRequest";
import { BadRequestError } from "../../errors/errors";

const APP_URL = process.env.APP_URL || "http://localhost:5000";

export const isNameValid = (
  req: AuthenticatedRequest,
  res: Response
): boolean => {
  const { name } = req.body;
  if (!name || typeof name !== "string" || name.trim() === "") {
    throw new BadRequestError("Vul een geldige klasnaam in");
  }
  return true;
};

/**
 * Create classroom
 * @route POST /teacher/classes
 * returns the created class in the response body
 */
export const createClassroom = asyncHandler(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const { name } = req.body;
    const teacherId: number = getUserFromAuthRequest(req).id;

    isNameValid(req, res) // if invalid, an error is thrown

    const classroom = await classService.createClass(name, teacherId);
    res.status(201).json({ message: "Klas aangemaakt", classroom });
  }
);

/**
 * Delete a classroom
 * @route DELETE /teacher/classes/:classId
 * @param classId - id of the class to be deleted
 */ 
export const deleteClassroom = asyncHandler(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const teacherId: number = getUserFromAuthRequest(req).id;

    await classService.deleteClass(classId, teacherId);
    res.status(200).json({ message: `Klas met id ${classId} verwijderd` });
  }
);

/**
 * Get join link
 * @route GET /teacher/classes/:classId/join-link
 * @param classId - id of the class for which the join link is fetched
 * returns the join link in the response body
 */
export const getJoinLink = asyncHandler(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const teacherId: number = getUserFromAuthRequest(req).id;

    const joinCode = await classService.getJoinCode(classId, teacherId);

    const joinLink = `${APP_URL}/student/classes/join?joinCode=${joinCode}`;
    res.status(200).json({ joinLink });
  }
);

/**
 * Regenerate join link
 * @route PATCH /teacher/classes/:classId/regenerate-join-link
 * @param classId - id of the class for which the join link is regenerated
 * returns the new join link in the response body
 */
export const regenerateJoinLink = asyncHandler(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const teacherId: number = getUserFromAuthRequest(req).id;

    const newJoinCode = await classService.regenerateJoinCode(
      classId,
      teacherId
    );
    const joinLink = `${APP_URL}/student/classes/join?joinCode=${newJoinCode}`;
    res.status(200).json({ joinLink });
  }
);

/**
 * Get classroom students
 * @route GET /teacher/classes/:classId/students
 * @param classId - id of the class for which the students are fetched
 * returns a list of all students in the class in the response body
 */
export const getClassroomStudents = asyncHandler(
  async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    const classId: number = parseInt(req.params.classId);
    const teacherId: number = getUserFromAuthRequest(req).id;

    // include user details of the students
    const students: (Student & {user: User})[] = await classService.getStudentsByClass(classId, teacherId);
    res.status(200).json({ students });
  }
);

=== ./teacher/teacherLocalLearningObjectController.ts ===
import { Request, Response } from "express";
import asyncHandler from "express-async-handler";
import LocalLearningObjectService, {
  LocalLearningObjectData,
} from "../../services/localLearningObjectService";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";

/**
 * Maak een nieuw leerobject.
 * POST /teacher/learningObjects
 */
export const createLocalLearningObject = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId) {
      res.status(401);
      throw new Error("Geen geldige teacher-gebruiker.");
    }

    const data: LocalLearningObjectData = req.body;
    // Eventuele extra validatie (bv. velden checken) kan hier

    const createdLO = await LocalLearningObjectService.createLearningObject(
      teacherId,
      data
    );
    res.status(201).json({
      message: "Leerobject aangemaakt",
      learningObject: createdLO,
    });
  }
);

/**
 * Haal alle leerobjecten op van deze teacher.
 * GET /teacher/learningObjects
 */
export const getLocalLearningObjects = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId) {
      res.status(401);
      throw new Error("Geen geldige teacher-gebruiker.");
    }

    const objects =
      await LocalLearningObjectService.getAllLearningObjectsByTeacher(
        teacherId
      );
    res.json(objects);
  }
);

/**
 * Haal één leerobject op.
 * GET /teacher/learningObjects/:id
 */
export const getLocalLearningObjectById = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId) {
      res.status(401);
      throw new Error("Geen geldige teacher-gebruiker.");
    }

    const { id } = req.params;
    const found = await LocalLearningObjectService.getLearningObjectById(id);

    if (!found) {
      res.status(404);
      throw new Error("Leerobject niet gevonden");
    }

    // Check of deze teacher de eigenaar is
    if (found.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerobject");
    }

    res.json(found);
  }
);

/**
 * Update een leerobject.
 * PUT /teacher/learningObjects/:id
 */
export const updateLocalLearningObject = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId) {
      res.status(401);
      throw new Error("Geen geldige teacher-gebruiker.");
    }

    const { id } = req.params;
    const data: Partial<LocalLearningObjectData> = req.body;

    // Check of leerobject bestaat en van deze teacher is
    const existing = await LocalLearningObjectService.getLearningObjectById(id);
    if (!existing) {
      res.status(404);
      throw new Error("Leerobject niet gevonden");
    }
    if (existing.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerobject");
    }

    const updated = await LocalLearningObjectService.updateLearningObject(
      id,
      data
    );
    res.json({
      message: "Leerobject bijgewerkt",
      learningObject: updated,
    });
  }
);

/**
 * Verwijder een leerobject.
 * DELETE /teacher/learningObjects/:id
 */
export const deleteLocalLearningObject = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId) {
      res.status(401);
      throw new Error("Geen geldige teacher-gebruiker.");
    }

    const { id } = req.params;
    const existing = await LocalLearningObjectService.getLearningObjectById(id);
    if (!existing) {
      res.status(404);
      throw new Error("Leerobject niet gevonden");
    }
    if (existing.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerobject");
    }

    await LocalLearningObjectService.deleteLearningObject(id);
    res.json({ message: "Leerobject verwijderd" });
  }
);

=== ./teacher/teacherLocalLearningPathController.ts ===
import { Request, Response } from "express";
import asyncHandler from "express-async-handler";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import LocalLearningPathService from "../../services/localLearningPathService";

/**
 * POST /teacher/learningPaths
 *   -> nieuw leerpad (zonder nodes)
 */
export const createLocalLearningPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    // We gaan ervan uit dat protectAnyUser al checkt of ingelogd, maar we doen extra check:
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Alleen leerkrachten kunnen leerpaden aanmaken.");
    }

    const { title, language, description, image } = req.body;
    if (!title || !language) {
      res.status(400);
      throw new Error("Vereiste velden: title, language (optioneel: description, image).");
    }

    const newPath = await LocalLearningPathService.createLearningPath(teacherId, {
      title,
      language,
      description: description || "",
      image: image || null,
    });

    res.status(201).json({
      message: "Leerpad aangemaakt",
      learningPath: newPath,
    });
  }
);

/**
 * GET /teacher/learningPaths
 */
export const getLocalLearningPaths = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Alleen leerkrachten kunnen hun leerpaden opvragen.");
    }

    const paths = await LocalLearningPathService.getAllLearningPathsByTeacher(teacherId);
    res.json(paths);
  }
);

/**
 * GET /teacher/learningPaths/:pathId
 */
export const getLocalLearningPathById = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId } = req.params;
    const path = await LocalLearningPathService.getLearningPathById(pathId);
    if (!path) {
      res.status(404);
      throw new Error("Leerpad niet gevonden");
    }
    if (path.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerpad.");
    }

    res.json(path);
  }
);

/**
 * PUT /teacher/learningPaths/:pathId
 */
export const updateLocalLearningPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId } = req.params;
    const existingPath = await LocalLearningPathService.getLearningPathById(pathId);
    if (!existingPath) {
      res.status(404);
      throw new Error("Leerpad niet gevonden");
    }
    if (existingPath.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerpad.");
    }

    const { title, language, description, image } = req.body;

    const updatedPath = await LocalLearningPathService.updateLearningPath(pathId, {
      title,
      language,
      description,
      image,
    });

    res.json({
      message: "Leerpad bijgewerkt",
      learningPath: updatedPath,
    });
  }
);

/**
 * DELETE /teacher/learningPaths/:pathId
 */
export const deleteLocalLearningPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId } = req.params;
    const existingPath = await LocalLearningPathService.getLearningPathById(pathId);
    if (!existingPath) {
      res.status(404);
      throw new Error("Leerpad niet gevonden");
    }
    if (existingPath.creatorId !== teacherId) {
      res.status(403);
      throw new Error("Je bent niet de eigenaar van dit leerpad.");
    }

    await LocalLearningPathService.deleteLearningPath(pathId);
    res.json({ message: "Leerpad verwijderd" });
  }
);

=== ./teacher/teacherLocalLearningPathNodesController.ts ===
// src/controllers/teacher/teacherLocalLearningPathNodesController.ts

import { Request, Response } from "express";
import asyncHandler from "express-async-handler";
import { AuthenticatedRequest } from "../../interfaces/extendedTypeInterfaces";
import localLearningPathNodeService from "../../services/localLearningPathNodeService";

/**
 * GET /teacher/learningPaths/:pathId/nodes
 */
export const getNodesForPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId } = req.params;
    const nodes = await localLearningPathNodeService.getAllNodesForPath(
      teacherId,
      pathId
    );
    res.json(nodes);
  }
);

/**
 * POST /teacher/learningPaths/:pathId/nodes
 *  -> node aanmaken
 *  -> Body-velden:
 *     {
 *       "isExternal": true/false,
 *       // Als extern: dwengoHruid, dwengoLanguage, dwengoVersion
 *       // Als lokaal: localLearningObjectId
 *       "start_node": bool
 *     }
 */
export const createNodeForPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId } = req.params;
    const {
      isExternal,
      localLearningObjectId,
      dwengoHruid,
      dwengoLanguage,
      dwengoVersion,
      start_node,
    } = req.body;

    // Overdragen naar service
    const newNode = await localLearningPathNodeService.createNodeForPath(teacherId, pathId, {
      isExternal: !!isExternal,
      localLearningObjectId,
      dwengoHruid,
      dwengoLanguage,
      dwengoVersion,
      start_node: !!start_node,
    });

    res.status(201).json({
      message: "Node aangemaakt",
      node: newNode,
    });
  }
);

/**
 * PUT /teacher/learningPaths/:pathId/nodes/:nodeId
 * -> node updaten
 * -> Body-velden (optioneel):
 *     {
 *       "isExternal": true/false,
 *       "localLearningObjectId": "...",
 *       "dwengoHruid": "...",
 *       "dwengoLanguage": "...",
 *       "dwengoVersion": number,
 *       "start_node": bool
 *     }
 */
export const updateNodeForPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId, nodeId } = req.params;
    const {
      isExternal,
      localLearningObjectId,
      dwengoHruid,
      dwengoLanguage,
      dwengoVersion,
      start_node,
    } = req.body;

    const updatedNode = await localLearningPathNodeService.updateNodeForPath(
      teacherId,
      pathId,
      nodeId,
      {
        isExternal,
        localLearningObjectId,
        dwengoHruid,
        dwengoLanguage,
        dwengoVersion,
        start_node,
      }
    );

    res.json({
      message: "Node bijgewerkt",
      node: updatedNode,
    });
  }
);

/**
 * DELETE /teacher/learningPaths/:pathId/nodes/:nodeId
 */
export const deleteNodeFromPath = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const teacherId = req.user?.id;
    if (!teacherId || req.user?.role !== "TEACHER") {
      res.status(403);
      throw new Error("Niet geautoriseerd.");
    }

    const { pathId, nodeId } = req.params;
    await localLearningPathNodeService.deleteNodeFromPath(teacherId, pathId, nodeId);
    res.json({ message: "Node verwijderd uit leerpad" });
  }
);

=== ./errors.ts ===
export class AppError extends Error {
    public statusCode: number;
    constructor(message: string, statusCode: number) {
        super(message);
        this.name = this.constructor.name;
        this.statusCode = statusCode;
    }
}

export class NotFoundError extends AppError {
    constructor(message: string) {
        super(message, 404);
    }
}

export class AccesDeniedError extends AppError {
    constructor(message: string) {
        super(message, 403);
    }
}

export class BadRequestError extends AppError {
    constructor(message: string) {
        super(message, 400);
    }
}

export class ConflictError extends AppError {
    constructor(message: string) {
        super(message, 409);
    }
}

export class UnauthorizedError extends AppError {
    constructor(message: string) {
        super(message, 401);
    }
}

=== ./getUserFromAuthRequest.ts ===
import { UnauthorizedError } from "../errors/errors";
import { AuthenticatedRequest } from "../interfaces/extendedTypeInterfaces";
import { z } from 'zod';

const AuthUserSchema = z.object({
    id: z.number(),
    email: z.string().email()
});

// since the user property in AuthenticatedRequest could be undefined, use this function to extract it safely
export function getUserFromAuthRequest(req: AuthenticatedRequest): { id: number, email: string } {
    // check that user is set
    if (!req.user) {
        throw new UnauthorizedError("Authentication required");
    }

    // check that user object has correct structure
    try {
        return AuthUserSchema.parse(req.user);
    } catch (error) {
        if (error instanceof z.ZodError) {
            throw new UnauthorizedError("Invalid user object in request");
        }
        throw error;
    }
}

=== ./extendedTypeInterfaces.ts ===
import { Role, Student, Teacher } from '@prisma/client';
import { Request } from 'express';


export interface AuthenticatedUser {
    id: number;
    role?: Role;
    teacher?: Teacher;
    student?: Student;
    email: string;
}

// Uitbreiding van het Express Request-type zodat we een user-property hebben
export interface AuthenticatedRequest extends Request {
    user?: AuthenticatedUser;
}
=== ./authAnyUserMiddleware.ts ===
import { Request, Response, NextFunction } from "express";
import asyncHandler from "express-async-handler";
import jwt from "jsonwebtoken";
import { PrismaClient, Role, Teacher, Student, User } from "@prisma/client";
import { AuthenticatedRequest, AuthenticatedUser } from "../interfaces/extendedTypeInterfaces";
const prisma = new PrismaClient();

interface JwtPayload {
  id: number;
}

export const protectAnyUser = asyncHandler(
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    let token: string | undefined;
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      try {
        token = req.headers.authorization.split(" ")[1];
        const decoded = jwt.verify(
          token,
          process.env.JWT_SECRET as string
        ) as JwtPayload;

        // Zoek de gebruiker in de database
        const user: User | null = await prisma.user.findUnique({
          where: { id: decoded.id },
        });
        if (!user) {
          res.status(401).json({ error: "Gebruiker niet gevonden." });
          return;
        }

        // Bouw het authUser object op met basisgegevens
        const authUser: AuthenticatedUser = { id: user.id, role: user.role , email: user.email };

        // Als de gebruiker een teacher is, haal dan de teacher-specifieke data op
        if (user.role === "TEACHER") {
          const teacher: Teacher | null = await prisma.teacher.findUnique({
            where: { userId: user.id },
            include: {
              teacherFeedbacks: true,
              invite: true,
              createdLearningPaths: true,
              createdLearningObjects: true,
              teaches: true,
            },
          });
          if (teacher) {
            authUser.teacher = teacher;
          }
        }
        // Als de gebruiker een student is, haal dan de student-specifieke data op
        else if (user.role === "STUDENT") {
          const student: Student | null = await prisma.student.findUnique({
            where: { userId: user.id },
            include: {
              progress: true,
              joinRequests: true,
              classes: true,
            },
          });
          if (student) {
            authUser.student = student;
          }
        }

        req.user = authUser;
        next();
      } catch (error) {
        console.error(error);
        res.status(401).json({ error: "Niet geautoriseerd, token mislukt." });
      }
    } else {
      res.status(401).json({ error: "Geen token, niet geautoriseerd." });
    }
  }
);

=== ./errorMiddleware.ts ===
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../errors/errors';

const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction): void => {
  if (err instanceof AppError) {
    res.status(err.statusCode)
  } else {
    const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
    res.status(statusCode);
  }
  
  res.json({
    message: err.message,
    // Alleen de stack weergeven als je niet in productie bent:
    stack: process.env.NODE_ENV === "production" ? undefined : err.stack,
  });
};

export default errorHandler;

=== ./questionsAuthMiddleware.ts ===
import { Response, NextFunction } from "express";
import asyncHandler from "express-async-handler";
import { PrismaClient } from "@prisma/client";
import { AuthenticatedRequest } from "../interfaces/extendedTypeInterfaces";

const prisma = new PrismaClient();

export const authorizeStudentInTeamWithAssignment = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        if (req.user?.role !== "STUDENT") {
            res.status(403).json({ error: "Toegang geweigerd." });
            return;
        }

        const student = req.user.student;
        if (!student) {
            res.status(403).json({ error: "Studentgegevens niet gevonden." });
            return;
        }

        const assignmentId = Number(req.params.assignmentId);
        if (!assignmentId) {
            res.status(400).json({ error: "Assignment ID is vereist." });
            return;
        }

        const team = await prisma.team.findFirst({
            where: {
                students: {
                    some: {
                        userId: student.userId,
                    },
                },
                teamAssignments: {
                    some: {
                        assignmentId: assignmentId,
                    },
                },
            },
        });

        if (!team) {
            res.status(403).json({ error: "Student is niet in een team met deze opdracht." });
            return;
        }

        next();
    }
);

export const authorizeQuestion = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        const { questionId } = req.params;

        if (!req.user) {
            res.status(401).json({ error: "Niet geautoriseerd." });
            return;
        }

        const question = await prisma.question.findUnique({
            where: { id: Number(questionId) },
            include: {
                team: {
                    include: {
                        students: true,
                        class: { include: { ClassTeacher: true } }
                    }
                }
            }
        });

        if (!question) {
            res.status(404).json({ error: "Vraag niet gevonden." });
            return;
        }

        const isStudentInTeam = question.team.students.some(student => student.userId === req.user?.id);
        const isTeacherInClass = question.team.class.ClassTeacher.some(teacher => teacher.teacherId === req.user?.id);

        if (req.user.role === "STUDENT" && !isStudentInTeam) {
            res.status(403).json({ error: "Toegang geweigerd. Student zit niet in het team." });
            return;
        }

        if (req.user.role === "TEACHER" && !isTeacherInClass) {
            res.status(403).json({ error: "Toegang geweigerd. Leerkracht behoort niet tot de klas van deze vraag." });
            return;
        }

        next();
    }
);

export const authorizeOwnerOfQuestionMessage = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        const { questionMessageId } = req.params;

        if (!req.user) {
            res.status(401).json({ error: "Niet geautoriseerd." });
            return;
        }

        const questionMessage = await prisma.questionMessage.findUnique({
            where: { id: Number(questionMessageId) },
        });

        if (!questionMessage) {
            res.status(404).json({ error: "Vraaggesprek niet gevonden." });
            return;
        }

        if (questionMessage.userId !== req.user.id) {
            res.status(403).json({ error: "Toegang geweigerd. Gebruiker is niet de eigenaar van dit vraaggesprek." });
            return;
        }

        next();
    }
);

export const authorizeStudentInTeamThatCreatedQuestion = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        const { teamId } = req.params;

        if (!req.user || req.user.role !== "STUDENT") {
            res.status(401).json({ error: "Niet geautoriseerd." });
            return;
        }

        const student = req.user.student;
        if (!student) {
            res.status(403).json({ error: "Studentgegevens niet gevonden." });
            return;
        }

        const team = await prisma.team.findUnique({
            where: { id: Number(teamId) },
            include: {
                students: true,
            },
        });

        if (!team) {
            res.status(404).json({ error: "Team niet gevonden." });
            return;
        }

        const isStudentInTeam = team.students.some(student => student.userId === req.user?.id);

        if (!isStudentInTeam) {
            res.status(403).json({ error: "Toegang geweigerd. Student is niet in dit team." });
            return;
        }
        next();
    }
);

export const authorizeTeacherOfClass = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        const { classId } = req.params;

        if (!req.user || req.user.role !== "TEACHER") {
            res.status(401).json({ error: "Niet geautoriseerd." });
            return;
        }

        const classData = await prisma.class.findUnique({
            where: { id: Number(classId) },
            include: {
                ClassTeacher: true,
            },
        });

        if (!classData) {
            res.status(404).json({ error: "Klas niet gevonden." });
            return;
        }

        const isTeacherOfClass = classData.ClassTeacher.some(teacher => teacher.teacherId === req.user?.id);

        if (!isTeacherOfClass) {
            res.status(403).json({ error: "Toegang geweigerd. Leerkracht behoort niet tot deze klas." });
            return;
        }

        next();
    }
);

export const authorizeTeacherOfAssignmentClass = asyncHandler(
    async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
        const { classId } = req.params;

        if (!req.user || req.user.role !== "TEACHER") {
            res.status(401).json({ error: "Niet geautoriseerd." });
            return;
        }

        const classData = await prisma.class.findUnique({
            where: { id: Number(classId) },
            include: {
                ClassTeacher: true,
                assignments: true
            },
        });

        if (!classData) {
            res.status(404).json({ error: "Klas niet gevonden." });
            return;
        }

        const isTeacherOfClass = classData.ClassTeacher.some(teacher => teacher.teacherId === req.user?.id);
        const isAssignmentOfClass = classData.assignments.some(assignment => assignment.assignmentId === Number(req.params.assignmentId));
        if (!isTeacherOfClass) {
            res.status(403).json({ error: "Toegang geweigerd. Leerkracht behoort niet tot deze klas." });
            return;
        }

        if (!isAssignmentOfClass) {
            res.status(403).json({ error: "Toegang geweigerd. Opdracht behoort niet tot deze klas." });
            return;
        }

        next();
    }
);



=== ./studentAuthMiddleware.ts ===
import * as jwt from 'jsonwebtoken';
import  asyncHandler from 'express-async-handler';
import { PrismaClient } from '@prisma/client';
import { Request, Response, NextFunction } from 'express';

const prisma = new PrismaClient();

interface AuthenticatedRequest extends Request {
  user?: {
    id: number;
    email: string;
  };
}

interface JwtPayload {
  id: number;
}

export const protectStudent = asyncHandler(
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    let token: string | undefined;

    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      try {
        token = req.headers.authorization.split(" ")[1];

        const decoded = jwt.verify(
          token,
          process.env.JWT_SECRET as string
        ) as JwtPayload;

        // Zoek de gebruiker (Student) en stel deze in op req.user
        const student = await prisma.student.findUnique({
          where: { userId: decoded.id },  // Finding the student by userId
          include: { user: { select: { id: true, email: true } } } // Fetching user details
        });

        if (!student) {
          res.status(401).json({ error: "Student niet gevonden." });
          return; // Ensure no further execution after sending the response
        }

        req.user = { id: student.userId, email: student.user.email };
        next();
      } catch (error) {
        console.error(error);
        res.status(401).json({ error: "Niet geautoriseerd, token mislukt." });
        return; // Ensure no further execution after sending the response
      }
    } else {
      res.status(401).json({ error: "Geen token, niet geautoriseerd." });
      return; // Ensure no further execution after sending the response
    }
  }
);
=== ./teacherAuthMiddleware.ts ===
import jwt from 'jsonwebtoken';
import asyncHandler from 'express-async-handler';
import { PrismaClient } from '@prisma/client';
import { Response, NextFunction } from 'express';
import { AuthenticatedRequest } from "../interfaces/extendedTypeInterfaces";

const prisma = new PrismaClient();

interface JwtPayload {
  id: number;
}

export const isTeacher = async (req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void> => {
  const userId = req.user?.id;
  if (!userId) {
    res.status(401).json({ error: "Unauthorized" });
    return; // Ensure the function exits after sending a response
  }

  const teacher = await prisma.teacher.findUnique({ where: { userId } });
  if (!teacher) {
    res.status(403).json({ error: "Access denied. Only teachers can perform this action." });
    return; // Prevent next() from running
  }

  next(); // Ensure next() is only called when valid
};

export const protectTeacher = asyncHandler(
  async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
    let token: string | undefined;

    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      try {
        token = req.headers.authorization.split(" ")[1];
        const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as JwtPayload;

        // Zoek de gebruiker (Teacher) en stel deze in op req.user
        const teacher = await prisma.teacher.findUnique({
          where: { userId: decoded.id },
          include: { user: { select: { id: true, email: true } } } // Exclude password
        });

        if (!teacher) {
          // Directly return the error response instead of throwingcd
          res.status(401).json({ error: "Leerkracht niet gevonden." });
          return;
        }

        req.user = { id: teacher.userId, email: teacher.user.email, role: 'TEACHER' };
        next();
      } catch (error) {
        console.error(error);
        // Return the error response directly
        res.status(401).json({ error: "Niet geautoriseerd, token mislukt." });
        return;
      }
    } else {
      // Return the error response directly
      res.status(401).json({ error: "Geen token, niet geautoriseerd." });
      return;
    }
  }
);

export { AuthenticatedRequest };

=== ./assignmentRoutes.ts ===
import express, {Router} from 'express';
import {AssignmentController} from "../controllers/assignmentController";

const router: Router = express.Router();
const controller = new AssignmentController();

// Geen protectTeacher nodig want teacherId is niet verwacht, iedereen mag de assignments opvragen
router.get("/:assignmentId", controller.getAssignmentsById);

export default router;

=== ./learningObject/learningObjectRoutes.ts ===
import express from "express";
import {
  getAllLearningObjectsController,
  getLearningObjectController,
  searchLearningObjectsController,
  getLearningObjectsForPathController,
  // [NIEUW] importeer de extra controller-functie:
  getLearningObjectByHruidLangVersionController,
} from "../../controllers/learningObject/learningObjectController";
import { protectAnyUser } from "../../middleware/authAnyUserMiddleware";

const router = express.Router();

// Bescherm alle endpoints, user moet ingelogd zijn (student/teacher/admin)
router.use(protectAnyUser);

router.get("/", getAllLearningObjectsController);
router.get("/search", searchLearningObjectsController);
router.get("/path/:pathId", getLearningObjectsForPathController);
// [NIEUW] Extra endpoint om op hruid+language+version te zoeken
// Voorbeeld:
//   GET /learningObjects/lookup?hruid=opdracht_leds&language=nl&version=2
router.get("/lookup", getLearningObjectByHruidLangVersionController);

router.get("/:id", getLearningObjectController);



export default router;

=== ./learningPath/learningPathRoutes.ts ===
import express, { Router } from "express";
import { 
  searchLearningPathsController, 
  getLearningPathByIdController 
} from "../../controllers/learningPath/learningPathController";
import { protectAnyUser } from "../../middleware/authAnyUserMiddleware";

const router: Router = express.Router();

// Bescherm alle endpoints zodat een user (met role) aanwezig is.
router.use(protectAnyUser);

// GET /learningPaths?language=nl&hruid=...&title=...&description=...&all=
router.get("/", searchLearningPathsController);

// GET /learningPaths/:pathId
router.get("/:pathId", getLearningPathByIdController);

export default router;

=== ./question/questionRoutes.ts ===
import express from "express";
import {
    createQuestionGeneral,
    createQuestionSpecific,
    createQuestionMessage,
    updateQuestion,
    updateQuestionMessage,
    getQuestion,
    getQuestionsTeam,
    getQuestionsClass,
    getQuestionsAssignment,
    getQuestionMessages,
    deleteQuestion,
    deleteQuestionMessage
} from "../../controllers/question/questionController";
import { protectAnyUser } from "../../middleware/authAnyUserMiddleware";
import {
    authorizeStudentInTeamWithAssignment,
    authorizeQuestion,
    authorizeOwnerOfQuestionMessage,
    authorizeStudentInTeamThatCreatedQuestion,
    authorizeTeacherOfClass,
    authorizeTeacherOfAssignmentClass
} from "../../middleware/questionsAuthMiddleware";

const router = express.Router();
router.use(protectAnyUser);

// Routes for creating questions
router.post(
    "/assignment/:assignmentId/learningPath/:learningPathId/",
    authorizeStudentInTeamWithAssignment,
    createQuestionGeneral
);
router.post(
    "/assignment/:assignmentId/learningPath/:learningPathId/learningObject/:learningObjectId/",
    authorizeStudentInTeamWithAssignment,
    createQuestionSpecific
);
router.post(
    "/:questionId/message",
    authorizeQuestion,
    createQuestionMessage
);

// Routes for updating questions
router.patch(
    "/:questionId",
    authorizeQuestion,
    updateQuestion);

router.patch(
    "/:questionId/message/:questionMessageId",
    authorizeOwnerOfQuestionMessage,
    updateQuestionMessage);

// Routes for retrieving questions
router.get(
    "/:questionId",
    authorizeQuestion,
    getQuestion
);
router.get(
    "/team/:teamId/",
    authorizeStudentInTeamThatCreatedQuestion,
    getQuestionsTeam
);
router.get(
    "/class/:classId",
    authorizeTeacherOfClass,
    getQuestionsClass
);
router.get(
    "/assignment/:assignmentId/class/:classId",
    authorizeTeacherOfAssignmentClass,
    getQuestionsAssignment
);
router.get(
    "/:questionId/messages",
    authorizeQuestion,
    getQuestionMessages
);

// Routes for deleting questions
router.delete(
    "/:questionId",
    authorizeQuestion,
    deleteQuestion
);
router.delete(
    "/:questionId/message/:questionMessageId",
    authorizeOwnerOfQuestionMessage,
    deleteQuestionMessage
);

export default router;

=== ./student/studentAssignmentRoutes.ts ===
import express, { Router } from "express";
import { getStudentAssignments } from "../../controllers/student/studentAssignmentController";
import { protectStudent } from "../../middleware/studentAuthMiddleware";

const router: Router = express.Router();

router.get("/", protectStudent, getStudentAssignments);

export default router;

=== ./student/studentAuthRoutes.ts ===
import express from 'express';
import { registerStudent, loginStudent } from '../../controllers/student/studentAuthController';

const router = express.Router();

// Registreren van een leerling
router.post("/register", registerStudent);

// Inloggen van een leerling
router.post("/login", loginStudent);

export default router;


=== ./student/studentClassRoutes.ts ===
import express from 'express';
import { protectStudent } from '../../middleware/studentAuthMiddleware';
import { createJoinRequest } from '../../controllers/joinrequest/joinRequestController'

const router = express.Router();

// Alleen studenten mogen deze route gebruiken
router.post("/join", protectStudent, createJoinRequest);

// kan een student al een overzicht van al z'n klassen zien? 

export default router;


=== ./teacher/feedbackRoutes.ts ===
import express from "express";
import controller from "../../controllers/teacher/feedbackController";
import {protectTeacher} from "../../middleware/teacherAuthMiddleware";

const router = express.Router();

router.get('assignment/:assignmentId/evaluation/:evaluationId', protectTeacher, controller.getAllFeedbackForEvaluation);
router.get('submission/:submissionId', protectTeacher, controller.getFeedbackForSubmission);
router.patch('submission/:submissionId', protectTeacher, controller.updateFeedbackForSubmission);
router.delete('submission/:submissionId', protectTeacher, controller.deleteFeedbackForSubmission);

router.post('/', protectTeacher, controller.createFeedback);


export default router;

=== ./teacher/teacherAssignmentRoutes.ts ===
import express, {Router} from 'express';
import { AssignmentTeacherController } from "../../controllers/teacher/teacherAssignmentController";
import {protectTeacher} from "../../middleware/teacherAuthMiddleware";

const router: Router = express.Router();
const controller = new AssignmentTeacherController();

router.post("/", protectTeacher, controller.createAssignmentForClass);
router.get("/class/:classId", protectTeacher, controller.getAssignmentsByClass);
router.patch("/:assignmentId", protectTeacher, controller.updateAssignment);
router.delete("/:assignmentId", protectTeacher, controller.deleteAssignment);

export default router;

=== ./teacher/teacherAuthRoutes.ts ===
import express from 'express';
import { registerTeacher, loginTeacher } from '../../controllers/teacher/teacherAuthController';

const router = express.Router();

// Route voor registratie van een leerkracht
router.post("/register", registerTeacher);

// Route voor inloggen van een leerkracht
router.post("/login", loginTeacher);

export default router;


=== ./teacher/teacherClassRoutes.ts ===
import express from 'express';
import { protectTeacher } from '../../middleware/teacherAuthMiddleware';
import {
  createClassroom,
  deleteClassroom,
  getJoinLink,
  regenerateJoinLink,
  getClassroomStudents,
} from '../../controllers/teacher/teacherClassController';
import { 
  createInvite,
  getPendingInvitesForClass,
  getPendingInvitesForTeacher,
  updateInviteStatus,
  deleteInvite
} from '../../controllers/teacher/inviteController';
import { 
  getJoinRequestsByClass,
  updateJoinRequestStatus
} from '../../controllers/joinrequest/joinRequestController';

const router = express.Router();

// Alleen leerkrachten mogen deze routes gebruiken
router.use(protectTeacher);

// routes for classes
router.post("/", createClassroom);
router.delete("/:classId", deleteClassroom);
router.get("/:classId/join-link", getJoinLink);
router.patch("/:classId/regenerate-join-link", regenerateJoinLink);
router.get("/:classId/students", getClassroomStudents);

// routes for invites
router.post("/:classId/invites", createInvite);
router.get("/:classId/invites", getPendingInvitesForClass);
router.delete("/:classId/invites/:inviteId", deleteInvite);
router.get("/invites", getPendingInvitesForTeacher);
router.patch("/invites/:inviteId", updateInviteStatus);

// routes for join requests
router.get("/:classId/join-requests", getJoinRequestsByClass);
router.patch("/:classId/join-requests/:requestId", updateJoinRequestStatus);

export default router;

=== ./teacher/teacherLocalLearningObjectRoutes.ts ===
import express from "express";
import {
  createLocalLearningObject,
  getLocalLearningObjects,
  getLocalLearningObjectById,
  updateLocalLearningObject,
  deleteLocalLearningObject,
} from "../../controllers/teacher/teacherLocalLearningObjectController";
import { protectTeacher } from "../../middleware/teacherAuthMiddleware";

const router = express.Router();

// Alle routes hier alleen toegankelijk voor geauthenticeerde teachers
router.use(protectTeacher);

/**
 * POST /teacher/learningObjects -> nieuw leerobject aanmaken
 * GET  /teacher/learningObjects -> alle leerobjecten van deze teacher
 */
router
  .route("/")
  .post(createLocalLearningObject)
  .get(getLocalLearningObjects);

/**
 * GET    /teacher/learningObjects/:id -> 1 leerobject ophalen
 * PATCh   /teacher/learningObjects/:id -> updaten (gedeeltelijk)
 * DELETE /teacher/learningObjects/:id -> verwijderen
 */
router
  .route("/:id")
  .get(getLocalLearningObjectById)
  .patch(updateLocalLearningObject)
  .delete(deleteLocalLearningObject);

export default router;

=== ./teacher/teacherLocalLearningPathNodesRoutes.ts ===
import { Router } from "express";
import { protectAnyUser } from "../../middleware/authAnyUserMiddleware";
import {
  getNodesForPath,
  createNodeForPath,
  updateNodeForPath,
  deleteNodeFromPath,
} from "../../controllers/teacher/teacherLocalLearningPathNodesController";

const router = Router();
router.use(protectAnyUser);

/**
 * GET /teacher/learningPaths/:pathId/nodes
 *   -> haal alle nodes op voor dat leerpad
 */
router.get("/:pathId/nodes", getNodesForPath);

/**
 * POST /teacher/learningPaths/:pathId/nodes
 *   -> maak een nieuwe node in dit leerpad
 */
router.post("/:pathId/nodes", createNodeForPath);

/**
 * PUT /teacher/learningPaths/:pathId/nodes/:nodeId
 *   -> update de node
 */
router.put("/:pathId/nodes/:nodeId", updateNodeForPath);

/**
 * DELETE /teacher/learningPaths/:pathId/nodes/:nodeId
 *   -> verwijder de node
 */
router.delete("/:pathId/nodes/:nodeId", deleteNodeFromPath);

export default router;

=== ./teacher/teacherLocalLearningPathRoutes.ts ===
import { Router } from "express";
import { protectAnyUser } from "../../middleware/authAnyUserMiddleware";
import {
  createLocalLearningPath,
  getLocalLearningPaths,
  getLocalLearningPathById,
  updateLocalLearningPath,
  deleteLocalLearningPath,
} from "../../controllers/teacher/teacherLocalLearningPathController";

const router = Router();

// Zorg dat alleen ingelogde gebruikers (teachers/admin) toegang hebben
router.use(protectAnyUser);

/**
 * POST /teacher/learningPaths
 *   -> maak een nieuw leerpad aan (standaard zonder nodes)
 */
router.post("/", createLocalLearningPath);

/**
 * GET /teacher/learningPaths
 *   -> haal alle leerpaden op van de ingelogde teacher
 */
router.get("/", getLocalLearningPaths);

/**
 * GET /teacher/learningPaths/:pathId
 *   -> haal één leerpad op (mits je eigenaar bent)
 */
router.get("/:pathId", getLocalLearningPathById);

/**
 * PUT /teacher/learningPaths/:pathId
 *   -> update een leerpad
 */
router.put("/:pathId", updateLocalLearningPath);

/**
 * DELETE /teacher/learningPaths/:pathId
 *   -> verwijder een leerpad
 */
router.delete("/:pathId", deleteLocalLearningPath);

export default router;

=== ./assignmentService.ts ===
import { Assignment, PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default class AssignmentService {
  static async getAssignmentById(assignmentId: number): Promise<Assignment | null> {
    return prisma.assignment.findUnique({
      where: { id: assignmentId },
      // geen include meer, want there's no relation to learningPath
    });
  }
}


=== ./authorizationService.ts ===
import { PrismaClient, Role } from "@prisma/client";

const prisma = new PrismaClient();

export const isAuthorized = async (
  userId: number,
  requiredRole: Role,
  classId?: number
): Promise<boolean> => {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true, teacher: true, student: true },
  });

  if (!user) throw new Error("User not found");

  // Admins are always authorized
  if (user.role === Role.ADMIN) return true;

  if (requiredRole === Role.TEACHER && user.role !== Role.TEACHER) return false;
  if (requiredRole === Role.STUDENT && user.role !== Role.STUDENT) return false;

  // Extra check for teachers: ensure they teach this class
  if (requiredRole === Role.TEACHER && classId) {
    const teachesClass = await prisma.classTeacher.findFirst({
      where: { teacherId: userId, classId },
    });
    return teachesClass !== null;
  }

  // Extra check for students: ensure they are part of this class
  if (requiredRole === Role.STUDENT && classId) {
    const enrolled = await prisma.classStudent.findFirst({
      where: { studentId: userId, classId },
    });
    return enrolled !== null;
  }

  return true;
};

export const canUpdateOrDelete = async (
  userId: number,
  assignmentId: number
): Promise<boolean> => {
  if (!(await isAuthorized(userId, Role.TEACHER))) return false;

  // The teacher is authorized
  // Now there needs to be checked if the teacher has classes that have this assignment
  const allClassesTeacher: { classId: number }[] =
    await prisma.classTeacher.findMany({
      where: { teacherId: userId },
      select: { classId: true },
    });

  // Check if at least one of the classes of the teacher has the assignment
  const hasAssignment = await prisma.classAssignment.findFirst({
    where: {
      assignmentId,
      classId: { in: allClassesTeacher.map((c) => c.classId) },
    },
  });
  return hasAssignment !== null;
};

=== ./classService.ts ===
import {Class, ClassStudent, ClassTeacher, PrismaClient, Student, User} from "@prisma/client";
import crypto from 'crypto';
import { AccesDeniedError, BadRequestError, NotFoundError } from "../errors/errors";

const prisma = new PrismaClient();

export type ClassWithLinks = Class & { classLinks: ClassStudent[] };

export default class ClassService {
    static async createClass (name: string, teacherId: number): Promise<Class> {
        // Generate a unique join code (e.g., an 8-digit hex string)
        const joinCode = await this.generateUniqueCode();

        const classroom = await prisma.class.create({
            data: {
                name: name, // name field matches the Class schema
                code: joinCode, // code field matches the Class schema
            }
        });

        // Now that you have the class id, create the ClassTeacher record
        await prisma.classTeacher.create({
            data: {
                teacherId: teacherId, // teacherId links to the teacher record
                classId: classroom.id, // Use the id of the newly created class
            }
        });

        return classroom;
    };

    // this function checks if the class exists and if the teacher is associated with the class
    // if either of these conditions are not met, an error is thrown
    private static async verifyClassAndTeacher(classId: number, teacherId: number): Promise<void> {
        // Check if the class exists
        const classroom = await prisma.class.findUnique({
            where: { id: classId },
        });
        if (!classroom) {
            throw new NotFoundError(`Class with id ${classId} not found`);
        }

        // Check if the teacher is associated with the class
        const isTeacher = await this.isTeacherOfClass(classId, teacherId);
        if (!isTeacher) {
            throw new AccesDeniedError(`Acces denied: Teacher ${teacherId} is not part of class ${classId}`);
        }
        return;
    }

    // Delete a class by ID
    static async deleteClass (classId: number, teacherId: number): Promise<Class> {
        await this.verifyClassAndTeacher(classId, teacherId);
        return await prisma.class.delete({ where: { id: classId } });   // onDelete: Cascade in the prisma schema makes sure that all related records are also deleted
    };

    // Get all classes taught by a given teacher
    static async getClassesByTeacher (teacherId: number): Promise<Class[]> {
        // Fetch all classes where the teacher is assigned
        return prisma.class.findMany({
            where: {
                ClassTeacher: {
                    some: {
                        teacherId: teacherId, // Filter for the given teacherId
                    },
                },
            }
        });
    };

    // Get all classes a student is partaking in
    static async getClassesByStudent (studentId: number): Promise<Class[]> {
        // Fetch all classes where the student is enrolled
        return prisma.class.findMany({
            where: {
                classLinks: {
                    some: {
                        studentId: studentId, // Filter for the given studentId
                    },
                },
            }
        });
    };

    // Function to check if the requester is the teacher of the class
    static async isTeacherOfClass(classId: number, teacherId: number): Promise<boolean> {
        const classTeacher: ClassTeacher | null = await prisma.classTeacher.findUnique({
            where: {
                teacherId_classId: {
                    teacherId: teacherId,
                    classId: classId,
                },
            },
        });
        return classTeacher !== null;
    };

    // Get all students from a given class
    static async getStudentsByClass(classId: number, teacherId: number): Promise<(Student & {user: User})[]> { 
        await this.verifyClassAndTeacher(classId, teacherId);

        const classStudents = await prisma.classStudent.findMany({
            where: { classId },
            include: {
                student: {
                    include: { user: true }, // include user details
                }
            }
        });
        return classStudents.map((cs) => cs.student);
    };

    static async addStudentToClass(studentId: number, classId: number): Promise<ClassStudent> {
        return prisma.classStudent.create({
            data: {
                studentId,
                classId,
            },
        });
    };

    // Check if student is already in the class
    static async isStudentInClass(classroom: ClassWithLinks, studentId: number): Promise<boolean> {
        return classroom.classLinks.some((link: ClassStudent) => link.studentId === studentId);
    };

    static async removeStudentFromClass(studentId: number, classId: number): Promise<ClassStudent> {
        return prisma.classStudent.delete({
            where: {
                studentId_classId: {
                    studentId,
                    classId,
                },
            },
        });
    };

    // Return all classes
    static async getAllClasses(): Promise<Class[]> {
        // Returns an empty array if nothing is found
        return prisma.class.findMany();
    };

    // Read a class by ID
    static async getClassById(id: number): Promise<Class | null> {
        return prisma.class.findUnique({
            where: {id: id},
        });
    };

    // Give the class a new name
    static async updateClassName(classId: number, newName: string): Promise<Class> {
        return prisma.class.update({
            where: {id: classId},
            data: {name: newName},
        });
    };

    // Read a class by JoinCode
    static async getClassByJoinCode(joinCode: string): Promise<ClassWithLinks | null> {
        if (!joinCode) {
            throw new BadRequestError(`Invalid join code: ${joinCode}`);
        }
        return prisma.class.findUnique({
            where: {code: joinCode},  // Search by the joinCode (which is 'code' in the schema)
            include: {
                classLinks: true,
            }
        });
    };

    static async getJoinCode(classId: number, teacherId: number): Promise<string> {
        const classroom = await prisma.class.findUnique({
            where: { id: classId },
            select: { code: true }, // Only fetch the join code
        });
        if (!classroom) {
            throw new NotFoundError(`Class with id ${classId} not found`);
        }

        // Check if the teacher is associated with the class
        const isTeacher = await this.isTeacherOfClass(classId, teacherId);
        if (!isTeacher) {
            throw new AccesDeniedError(`Acces denied: Teacher ${teacherId} is not part of class ${classId}`);
        }

        return classroom.code;
    };

    // Function to generate a unique join code
    static async generateUniqueCode(): Promise<string> {
        let isUnique = false;
        let newJoinCode: string = "";

        while (!isUnique) {
            // Generate new join code
            newJoinCode = crypto.randomBytes(4).toString("hex");

            // Check if the code is unique in the database
            const existingClass = await prisma.class.findUnique({
                where: { code: newJoinCode },
            });

            if (!existingClass) {
                isUnique = true;
            }
        }

        return newJoinCode;
    };

    // Function to regenerate the join code for a class
    static async regenerateJoinCode(classId: number, teacherId: number): Promise<string> {
        await this.verifyClassAndTeacher(classId, teacherId);

        // Generate a unique join code
        const newJoinCode = await this.generateUniqueCode();

        // Update class with the new join code
        const updatedClass = await prisma.class.update({
            where: { id: classId },
            data: { code: newJoinCode },
        });

        return updatedClass.code;
    };
}

=== ./combinedLearningObjectService.ts ===

import {
    fetchAllDwengoObjects,
    fetchDwengoObjectById,
    searchDwengoObjects,
    getDwengoObjectsForPath,
    LearningObjectDto,
    // [NIEUW] importeer de functie om Dwengo-LO op te halen via hruid/lang/version
    fetchDwengoObjectByHruidLangVersion,
  } from "./dwengoLearningObjectService";
  import {
    getLocalLearningObjects,
    getLocalLearningObjectById,
    searchLocalLearningObjects,
    // [NIEUW] importeer de functie om lokaal LO op te halen via hruid/lang/version
    getLocalLearningObjectByHruidLangVersion,
  } from "./localDBLearningObjectService";
  
  /**
   * Haalt ALLE leerobjecten op: Dwengo + lokaal.
   */
  export async function getAllLearningObjects(
    isTeacher: boolean
  ): Promise<LearningObjectDto[]> {
    const dwengoObjs = await fetchAllDwengoObjects(isTeacher);
    const localObjs = await getLocalLearningObjects(isTeacher);
    return [...dwengoObjs, ...localObjs];
  }
  
  /**
   * Zoeken (Dwengo + lokaal)
   */
  export async function searchLearningObjects(
    isTeacher: boolean,
    searchTerm: string
  ): Promise<LearningObjectDto[]> {
    const dwengoResults = await searchDwengoObjects(isTeacher, searchTerm);
    const localResults = await searchLocalLearningObjects(isTeacher, searchTerm);
    return [...dwengoResults, ...localResults];
  }
  
  /**
   * Haal 1 leerobject op (op basis van 'id' – Dwengo _id of local ID).
   */
  export async function getLearningObjectById(
    id: string,
    isTeacher: boolean
  ): Promise<LearningObjectDto | null> {
    // Eerst Dwengo checken
    const fromDwengo = await fetchDwengoObjectById(id, isTeacher);
    if (fromDwengo) return fromDwengo;
  
    // Anders lokaal checken
    const fromLocal = await getLocalLearningObjectById(id, isTeacher);
    if (fromLocal) return fromLocal;
  
    return null;
  }
  
  /**
   * Haalt alle leerobjecten op die bij een leerpad (Dwengo) horen.
   * Wil je later ook lokale leerpaden toevoegen, pas deze functie aan.
   */
  export async function getLearningObjectsForPath(
    pathId: string,
    isTeacher: boolean
  ): Promise<LearningObjectDto[]> {
    return await getDwengoObjectsForPath(pathId, isTeacher);
  }
  
  // [NIEUW] Haal 1 leerobject op via hruid-language-version
  export async function getLearningObjectByHruidLangVersion(
    hruid: string,
    language: string,
    version: number,
    isTeacher: boolean
  ): Promise<LearningObjectDto | null> {
    // 1) Probeer Dwengo
    const fromDwengo = await fetchDwengoObjectByHruidLangVersion(
      hruid,
      language,
      version,
      isTeacher
    );
    if (fromDwengo) return fromDwengo;
  
    // 2) Probeer lokaal
    const fromLocal = await getLocalLearningObjectByHruidLangVersion(
      hruid,
      language,
      version,
      isTeacher
    );
    if (fromLocal) return fromLocal;
  
    return null;
  }
  
=== ./dwengoLearningObjectService.ts ===
import { dwengoAPI } from "../config/dwengoAPI";
import axios from "axios";

/**
 * De mogelijke content types (zie je enum in de oorspronkelijke code).
 */
enum ContentType {
  TEXT_PLAIN = "text/plain",
  TEXT_MARKDOWN = "text/markdown",
  IMAGE_IMAGE_BLOCK = "image/image-block",
  IMAGE_IMAGE = "image/image",
  AUDIO_MPEG = "audio/mpeg",
  VIDEO = "video",
  EVAL_MULTIPLE_CHOICE = "evaluation/multiple-choice",
  EVAL_OPEN_QUESTION = "evaluation/open-question",
}

/**
 * Mapping van Dwengo string => onze enum
 */
const permittedContentTypes = {
  "text/plain": ContentType.TEXT_PLAIN,
  "text/markdown": ContentType.TEXT_MARKDOWN,
  "image/image-block": ContentType.IMAGE_IMAGE_BLOCK,
  "image/image": ContentType.IMAGE_IMAGE,
  "audio/mpeg": ContentType.AUDIO_MPEG,
  "video": ContentType.VIDEO,
  "evaluation/multiple-choice": ContentType.EVAL_MULTIPLE_CHOICE,
  "evaluation/open-question": ContentType.EVAL_OPEN_QUESTION,
};

interface DwengoLearningObject {
  _id?: string;
  uuid?: string;
  hruid?: string;
  version?: number;
  language?: string;
  title?: string;
  description?: string;
  content_type?: string;
  keywords?: string[];
  target_ages?: number[];
  teacher_exclusive?: boolean;
  skos_concepts?: string[];
  copyright?: string;
  licence?: string;
  difficulty?: number;
  estimated_time?: number;
  available?: boolean;
  content_location?: string;
  created_at?: string;
  updatedAt?: string;
}

export interface LearningObjectDto {
  id: string;
  uuid: string;
  hruid: string;
  version: number;
  language: string;
  title: string;
  description: string;
  contentType: string;
  keywords: string[];
  targetAges: number[];
  teacherExclusive: boolean;
  skosConcepts: string[];
  copyright: string;
  licence: string;
  difficulty: number;
  estimatedTime: number;
  available: boolean;
  contentLocation?: string;
  createdAt: string;
  updatedAt: string;
  origin: "dwengo" | "local";
}

/**
 * Converteer Dwengo-object naar onze LearningObjectDto
 */
function mapDwengoToLocal(dwengoObj: DwengoLearningObject): LearningObjectDto {
  return {
    id: dwengoObj._id ?? "",
    uuid: dwengoObj.uuid ?? "",
    hruid: dwengoObj.hruid ?? "",
    version: dwengoObj.version ?? 1,
    language: dwengoObj.language ?? "",
    title: dwengoObj.title ?? "",
    description: dwengoObj.description ?? "",
    contentType:
      permittedContentTypes[
        (dwengoObj.content_type as keyof typeof permittedContentTypes) ?? ""
      ] ?? ContentType.TEXT_PLAIN,
    keywords: dwengoObj.keywords ?? [],
    targetAges: dwengoObj.target_ages ?? [],
    teacherExclusive: Boolean(dwengoObj.teacher_exclusive),
    skosConcepts: dwengoObj.skos_concepts ?? [],
    copyright: dwengoObj.copyright ?? "",
    licence: dwengoObj.licence ?? "",
    difficulty: dwengoObj.difficulty ?? 0,
    estimatedTime: dwengoObj.estimated_time ?? 0,
    available: dwengoObj.available ?? false,
    contentLocation: dwengoObj.content_location ?? "",
    createdAt: dwengoObj.created_at ?? "",
    updatedAt: dwengoObj.updatedAt ?? "",
    origin: "dwengo",
  };
}

// Alle Dwengo-objects
export async function fetchAllDwengoObjects(isTeacher: boolean): Promise<LearningObjectDto[]> {
  try {
    const params: Record<string, any> = {};
    if (!isTeacher) {
      params.teacher_exclusive = false;
      params.available = true;
    }
    const response = await dwengoAPI.get("/api/learningObject/search", { params });
    const dwengoData: DwengoLearningObject[] = response.data;
    return dwengoData.map(mapDwengoToLocal);
  } catch (error) {
    console.error("Fout bij fetchAllDwengoObjects:", error);
    throw new Error("Dwengo API call mislukt.");
  }
}

// Eén Dwengo-object op basis van _id
export async function fetchDwengoObjectById(
  id: string,
  isTeacher: boolean
): Promise<LearningObjectDto | null> {
  try {
    const params = { _id: id };
    const response = await dwengoAPI.get("/api/learningObject/getMetadata", { params });
    const dwengoObj: DwengoLearningObject = response.data;
    const mapped = mapDwengoToLocal(dwengoObj);

    if (!isTeacher && (mapped.teacherExclusive || !mapped.available)) {
      return null;
    }
    return mapped;
  } catch (error: any) {
    if (error.response && error.response.status === 404) {
      return null;
    }
    console.error("Fout bij fetchDwengoObjectById:", error);
    return null;
  }
}

// [NIEUW] Dwengo-object op basis van hruid, language, version
export async function fetchDwengoObjectByHruidLangVersion(
  hruid: string,
  language: string,
  version: number,
  isTeacher: boolean
): Promise<LearningObjectDto | null> {
  try {
    // Dwengo-API: /api/learningObject/getMetadata?hruid=...&language=...&version=...
    const params = { hruid, language, version };
    console.log("Dwengo params:", params);

    const response = await dwengoAPI.get("/api/learningObject/getMetadata", { params });
    const dwengoObj: DwengoLearningObject = response.data;
    const mapped = mapDwengoToLocal(dwengoObj);

    if (!isTeacher && (mapped.teacherExclusive || !mapped.available)) {
      return null;
    }
    return mapped;
  } catch (error: any) {
    if (error.response && error.response.status === 404) {
      return null;
    }
    console.error("Fout bij fetchDwengoObjectByHruidLangVersion:", error);
    return null;
  }
}

// Zoeken Dwengo-objects
export async function searchDwengoObjects(
  isTeacher: boolean,
  searchTerm: string
): Promise<LearningObjectDto[]> {
  try {
    const params: Record<string, any> = {};
    if (!isTeacher) {
      params.teacher_exclusive = false;
      params.available = true;
    }
    if (searchTerm) {
      params.searchTerm = searchTerm;
    }
    const response = await dwengoAPI.get("/api/learningObject/search", { params });
    const dwengoData: DwengoLearningObject[] = response.data;
    return dwengoData.map(mapDwengoToLocal);
  } catch (error) {
    console.error("Fout bij searchDwengoObjects:", error);
    throw new Error("Dwengo API search mislukt.");
  }
}

// Haal leerobjecten op voor een leerpad (Dwengo)
export async function getDwengoObjectsForPath(
  pathId: string,
  isTeacher: boolean
): Promise<LearningObjectDto[]> {
  try {
    const pathResp = await dwengoAPI.get("/api/learningPath/search", { params: { all: "" } });
    const allPaths: any[] = pathResp.data;
    const learningPath = allPaths.find((lp) => lp._id === pathId);
    if (!learningPath) {
      console.warn(`Leerpad met _id=${pathId} niet gevonden in Dwengo-API.`);
      return [];
    }
    const nodes = learningPath.nodes || [];
    const results: LearningObjectDto[] = [];

    for (const node of nodes) {
      try {
        const params = {
          hruid: node.learningobject_hruid,
          version: node.version,
          language: node.language,
        };
        const response = await dwengoAPI.get("/api/learningObject/getMetadata", { params });
        const dwengoObj: DwengoLearningObject = response.data;
        const mapped = mapDwengoToLocal(dwengoObj);

        if (!isTeacher && (mapped.teacherExclusive || !mapped.available)) {
          continue;
        }
        results.push(mapped);
      } catch (err) {
        console.error("Fout bij ophalen node:", err);
      }
    }
    return results;
  } catch (error) {
    console.error("Fout bij getDwengoObjectsForPath:", error);
    return [];
  }
}

=== ./feedbackService.ts ===
import { Feedback, PrismaClient } from '@prisma/client';


const prisma = new PrismaClient();

export default class FeedbackService {
    static async getAllFeedbackForEvaluation(assignmentId: number, evaluationId: string, teacherId: number): Promise<Feedback[]> {
        if (!await this.hasAssignmentRights(assignmentId, teacherId)) {
            throw new Error("The teacher is unauthorized to perform this action");
        }

        return prisma.feedback.findMany({
            where: {
                submission: {
                    evaluationId: evaluationId,
                    assignmentId: assignmentId
                },
            },
            include: {
                submission: true,
            },
        });
    }

    static async createFeedback(submissionId: number, teacherId: number, description: string): Promise<Feedback> {
        if (!await this.hasSubmissionRights(teacherId, submissionId)) {
            throw new Error("The teacher is unauthorized to perform this action");
        }

        // aantal evaluaties met deadline in de toekomst
        const deadline = await prisma.evaluation.findFirst({
            where: {
                submissions: {
                    some: {
                        submissionId: submissionId,
                    },
                }

                /*,
                deadline: {
                    gte: new Date()
                }
                    */
            }
        });

        // Als deadline in de toekomst ligt: error
        if (deadline !== null) {
            throw new Error("Deadline in toekomst");
        }

        return prisma.feedback.create({
            data: {
                submissionId: submissionId,
                teacherId: teacherId,
                description: description,
            },
        });
    }

    static async getFeedbackForSubmission(submissionId: number, teacherId: number): Promise<Feedback | null> {
        if (!await this.hasSubmissionRights(teacherId, submissionId)) {
            throw new Error("The teacher is unauthorized to perform this action");
        }

        return prisma.feedback.findUnique({
            where: {
                submissionId: submissionId,
            }
        });
    }

    static async updateFeedbackForSubmission(submissionId: number, description: string, teacherId: number): Promise<Feedback> {
        if (!await this.hasSubmissionRights(teacherId, submissionId)) {
            throw new Error("The teacher is unauthorized to perform this action");
        }

        return prisma.feedback.update({
            where: {
                submissionId: submissionId,
            },
            data: {
                description: description,
            },
        });
    }

    static async deleteFeedbackForSubmission(submissionId: number, teacherId: number): Promise<Feedback> {
        if (!await this.hasSubmissionRights(teacherId, submissionId)) {
            throw new Error("The teacher is unauthorized to perform this action");
        }

        return prisma.feedback.delete({
            where: {
                submissionId: submissionId,
            },
        });

    }

    static async hasAssignmentRights(assignmentId: number, teacherId: number) {
        // Tel aantal leerkrachten die rechten hebben op de evaluatie
        const teacherWithRights = await prisma.teacher.findFirst({
            where: {
                userId: teacherId,
                teaches: {
                    some: {
                        class: {
                            assignments: {
                                some: {
                                    assignment: {
                                        id: assignmentId,
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        );

        return teacherWithRights !== null;
    }

    static async hasSubmissionRights(teacherId: number, submissionId: number) {
        // Tel aantal leerkrachten die rechten hebben op de submission
        const teacherWithRights: number = await prisma.teacher.count({
            where: {
                userId: teacherId,
                teaches: {
                    some: {
                        class: {
                            assignments: {
                                some: {
                                    assignment: {
                                        submissions: {
                                            some: {
                                                submissionId: submissionId,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        );

        // Return true als teacher rechten heeft
        return teacherWithRights > 0;
    }
}
=== ./inviteService.ts ===
import { Invite, JoinRequestStatus, Class, PrismaClient } from "@prisma/client";
import classService from "./classService";
import { AccesDeniedError, BadRequestError, ConflictError, NotFoundError } from "../errors/errors";

const prisma = new PrismaClient();

export default class inviteService {

    private static async validateInvitePending(inviteId: number, otherTeacherId: number): Promise<Invite> {
        const invite: Invite | null = await prisma.invite.findFirst({
            where: {
                inviteId,
                otherTeacherId,
                status: JoinRequestStatus.PENDING,
            }
        });
        if (!invite) {
            throw new BadRequestError("Uitnodiging is niet pending of bestaat niet");
        }
        return invite;
    }

    static async createInvite(classTeacherId: number, otherTeacherId: number, classId: number): Promise<Invite> {
        // check if class exists
        const classroom: Class | null = await classService.getClassById(classId);
        if (!classroom) {
            throw new NotFoundError("Klas niet gevonden");
        }

        // check if teacher sending the invite is a teacher of the class
        const isTeacher: boolean = await classService.isTeacherOfClass(classId, classTeacherId);
        if (!isTeacher) {
            throw new AccesDeniedError("Leerkracht is geen beheerder van de klas");
        }

        // check if there's already a pending invite for this teacher and class
        const invite: Invite | null = await prisma.invite.findFirst({
            where: {
                otherTeacherId,
                classId,
                status: JoinRequestStatus.PENDING,
            },
        });
        if (invite) {
            throw new ConflictError("Er bestaat al een pending uitnodiging voor deze leerkracht en klas");
        }

        // check if the teacher to be added is not already a member of the class
        const isAlreadyTeacher: boolean = await classService.isTeacherOfClass(classId, otherTeacherId);
        if (isAlreadyTeacher) {
            throw new BadRequestError("Leerkracht is al lid van de klas");
        }

        // create the invite
        return await prisma.invite.create({
            data: {
                otherTeacherId,
                classTeacherId,
                classId,
                status: JoinRequestStatus.PENDING,
            },
        });
    }

    static async getPendingInvitesForClass(classTeacherId: number, classId: number): Promise<Invite[]> {
        // only a teacher of the class should be able to see the invites for the class
        const isTeacher: boolean = await classService.isTeacherOfClass(classId, classTeacherId);
        if (!isTeacher) {
            throw new AccesDeniedError("Leerkracht is geen beheerder van de klas");
        }
        return await prisma.invite.findMany({
            where: {
                classId,
                status: JoinRequestStatus.PENDING
            },  
        });
    }

    static async getPendingInvitesForTeacher(teacherId: number): Promise<Invite[]> {
        return prisma.invite.findMany({
            where: {
                otherTeacherId: teacherId,
                status: JoinRequestStatus.PENDING   // i don't think a teacher would ever really need to see invites that they already accepted or declined
            },
        });
    }

    static async acceptInviteAndJoinClass(teacherId: number, inviteId: number): Promise<Invite> {
        // check if invite is pending
        let invite: Invite = await this.validateInvitePending(inviteId, teacherId);
        
        [ invite ] = await prisma.$transaction([
            // accept invite
            prisma.invite.update({
                where: {
                    inviteId: invite.inviteId
                },
                data: {
                    status: JoinRequestStatus.APPROVED,
                },
            }),
            // add the teacher to the class
            prisma.classTeacher.create({
                data: {
                    teacherId,
                    classId: invite.classId
                }
            })
        ]);
        return invite;
    }

    static async declineInvite(teacherId: number, inviteId: number): Promise<Invite> {
        // check if invite is pending
        const invite: Invite = await this.validateInvitePending(inviteId, teacherId);

        // decline the invite
        return prisma.invite.update({
            where: {
                inviteId: invite.inviteId
            },
            data: {
                status: JoinRequestStatus.DENIED,
            }
        });
    }

    static async deleteInvite(classTeacherId: number, inviteId: number, classId: number): Promise<Invite> {
        // check if teacher is a teacher of the class 
        // (any teacher of the class can delete the invite, not just the one who created the invite)
        const isTeacher: boolean = await classService.isTeacherOfClass(classId, classTeacherId);
        if (!isTeacher) {
            throw new AccesDeniedError("Leerkracht is geen beheerder van de klas");
        }

        // delete the invite
        return await prisma.invite.delete({
            where: {
                inviteId,
                classId   // added this to make sure the invite belongs to the class that was passed in the arguments
            },
        });
    }

}

=== ./joinRequestService.ts ===
import {PrismaClient, JoinRequestStatus, JoinRequest} from "@prisma/client";
import classService from "./classService";
import {ClassWithLinks} from "./classService";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";
import { AccesDeniedError, BadRequestError, NotFoundError } from "../errors/errors";

const prisma = new PrismaClient();

export default class joinRequestService {

    // Validate whether the class exists before proceeding
    private static async validateClassExists(joinCode: string): Promise<ClassWithLinks> {
        const classroom: ClassWithLinks | null = await classService.getClassByJoinCode(joinCode);
        if (!classroom) {
            throw new NotFoundError(`Class with code ${joinCode} not found.`);
        }
        return classroom;
    }

    private static async updateAndValidateRequest(requestId: number, teacherId: number, classId: number, status: JoinRequestStatus): Promise<JoinRequest> {
        // check if teacher is allowed to approve/deny the request
        const isTeacher: boolean = await classService.isTeacherOfClass(classId, teacherId);
        if (!isTeacher) {
            throw new AccesDeniedError(`Teacher ${teacherId} is not a teacher of class ${classId}`);
        }

        const joinRequest: JoinRequest | null = await prisma.joinRequest.findFirst({
            where: { requestId, classId, status: JoinRequestStatus.PENDING },
        });
        if (!joinRequest) {
            throw new NotFoundError(`Join request ${requestId} for class ${classId} not found/not pending.`);
        }
        
        // Update the join request status
        const updatedRequest = await prisma.joinRequest.update({
            where: { requestId },
            data: { status: status },
        });

        return updatedRequest;
    }

    static async createJoinRequest(studentId: number, classId: number): Promise<JoinRequest> {
        return prisma.joinRequest.create({
            data: {
                studentId,
                classId: classId,
                status: JoinRequestStatus.PENDING,
            },
        });
    }

    static async createValidJoinRequest(studentId: number, joinCode: string): Promise<JoinRequest> {
        try {
            const classroom: ClassWithLinks = await this.validateClassExists(joinCode);

            // check if the student is already a member of the class
            if (await classService.isStudentInClass(classroom, studentId)) {
                throw new BadRequestError(`Student ${studentId} is already a member of class ${classroom.id}`);
            }

            // check if there's already a pending join request for this student and class
            const existingRequest: JoinRequest | null = await prisma.joinRequest.findFirst({
                where: {
                    studentId,
                    classId: classroom.id,
                    status: JoinRequestStatus.PENDING,
                },
            });
            if (existingRequest) {
                throw new BadRequestError(`There's already a pending join request for student ${studentId} and class ${classroom.id}`);
            }

            return await this.createJoinRequest(studentId, classroom.id);
        } catch (error) {
            this.handleError(error, "Error creating join request");
            // Without this Typescript does not accept the return type to just be Promise<JoinRequest>
            // but also wants it to be optionally "undefined".
            // Since I don't want that, I will just log the error here, and then pass the error to the
            // JoinRequestController which will handle accordingly.
            throw error;
        }
    };

    static async approveRequestAndAddStudentToClass(requestId: number, teacherId: number, classId: number): Promise<JoinRequest> {
        try {
            const updatedRequest: JoinRequest = await this.updateAndValidateRequest(requestId, teacherId, classId, JoinRequestStatus.APPROVED);

            // Add the student to the class
            await classService.addStudentToClass(updatedRequest.studentId, classId);
            return updatedRequest;
        } catch (error) {
            this.handleError(error, `Error approving join request ${requestId} for class ${classId}`);
            throw error;
        }
    };

    static async denyJoinRequest(requestId: number, teacherId: number, classId: number): Promise<JoinRequest> {
        try {
            return await this.updateAndValidateRequest(requestId, teacherId, classId, JoinRequestStatus.DENIED);
        } catch (error) {
            this.handleError(error, `Error denying join request ${requestId} for class ${classId}`);
            throw error;
        }
    };

    static async getJoinRequestsByClass(teacherId: number, classId: number): Promise<JoinRequest[]> {
        try {
            const isTeacher: boolean = await classService.isTeacherOfClass(classId, teacherId);
            if (!isTeacher) {
                throw new AccesDeniedError(`Teacher ${teacherId} is not a teacher of class ${classId}`);
            }
            return await prisma.joinRequest.findMany({
                where: { classId }
            });
        } catch (error) {
            this.handleError(error, `Error fetching join requests for class ${classId}`);
            return [];
        }
    }

    private static handleError(error: any, message: string): void {
        if (error instanceof PrismaClientKnownRequestError) {
            throw new Error(`Prisma error occurred: ${error.message}`);
        } else if (error instanceof Error) {
            error.message = `${message}: ${error.message}`;
            throw error;
        }
        throw new Error(`${message}: Unknown error occurred.`);
    }
}

=== ./learningPathService.ts ===
import { dwengoAPI } from "../config/dwengoAPI";

export interface LearningPathDto {
  _id: string; // Dwengo gebruikt _id
  hruid: string; // Human readable unique id
  language: string;
  title: string;
  description: string;
  image?: string;
  num_nodes?: number; // Aantal nodes in het pad
  num_nodes_left: number;
  nodes: any[]; // Array van nodes (zie Dwengo docs), elk met transitions, etc.
  createdAt?: string; // Als Dwengo 'created_at' meegeeft
  updatedAt?: string; // Als Dwengo 'updatedAt' meegeeft
}

/**
 * Hulpfunctie om JSON van Dwengo te mappen naar een LearningPathDto
 */
function mapDwengoPathToLocal(dwengoPath: any): LearningPathDto {
  return {
    _id: dwengoPath._id ?? "",
    hruid: dwengoPath.hruid ?? "",
    language: dwengoPath.language ?? "",
    title: dwengoPath.title ?? "",
    description: dwengoPath.description ?? "",
    image: dwengoPath.image ?? "",
    num_nodes: dwengoPath.num_nodes ?? 0,
    num_nodes_left: dwengoPath.num_nodes_left ?? 0,
    nodes: dwengoPath.nodes ?? [],
    createdAt: dwengoPath.created_at ?? "",
    updatedAt: dwengoPath.updatedAt ?? "",
  };
}

/**
 * Haalt alle leerpaden op via Dwengo API: /api/learningPath/search
 * - Je kunt filteren met all, language, title, description, hruid, ...
 *   (zie Dwengo docs)
 * @param filters Object met mogelijke zoekfilters
 */
export async function searchLearningPaths(
  filters: {
    language?: string;
    hruid?: string;
    title?: string;
    description?: string;
    all?: string; // leeg string => alles
  } = {}
): Promise<LearningPathDto[]> {
  try {
    // Zet de filters om naar Dwengo queryparams
    const params: Record<string, any> = {};

    // Dwengo-API ondersteunt: all, language, hruid, title, description
    // (zie docs: <dwengo-host>/api/learningPath/search?all=&language=nl&hruid=... etc.)
    if (filters.language) params.language = filters.language;
    if (filters.hruid) params.hruid = filters.hruid;
    if (filters.title) params.title = filters.title;
    if (filters.description) params.description = filters.description;

    // 'all=' => om alle paden op te halen
    if (filters.all !== undefined) {
      // Bijv. filters.all = "" → ?all=
      params.all = filters.all;
    }

    // GET call
    const response = await dwengoAPI.get("/api/learningPath/search", {
      params,
    });
    const dwengoData = response.data; // array van leerpaden

    // Map elk item naar LearningPathDto
    const results = dwengoData.map(mapDwengoPathToLocal);
    return results;
  } catch (error) {
    console.error("Fout bij searchLearningPaths:", error);
    throw new Error("Dwengo API call voor leerpaden mislukt.");
  }
}

/**
 * Haalt 1 leerpad op (niet voorzien in Dwengo met /getMetadata,
 * maar je kunt filteren in search op bijv. hruid of _id).
 *
 * Let op: Dwengo heeft geen dedicated "getLearningPathById" route;
 * je zoekt typically via search + hruid=... of all=...
 */
export async function getLearningPathByIdOrHruid(
  idOrHruid: string
): Promise<LearningPathDto | null> {
  try {
    // Probeer te zoeken met hruid=... of als je _id hebt, moet je 'all=' gebruiken en local filteren
    const params = { all: "" };
    const response = await dwengoAPI.get("/api/learningPath/search", {
      params,
    });
    const allPaths = response.data;

    // Zoeken in array op basis van _id of hruid
    const found = allPaths.find(
      (lp: any) => lp._id === idOrHruid || lp.hruid === idOrHruid
    );
    if (!found) return null;

    return mapDwengoPathToLocal(found);
  } catch (error) {
    console.error("Fout bij getLearningPathByIdOrHruid:", error);
    return null;
  }
}

=== ./localDBLearningObjectService.ts ===


import { PrismaClient, LearningObject } from "@prisma/client";
import { LearningObjectDto } from "./dwengoLearningObjectService";

const prisma = new PrismaClient();

/**
 * Converteert een Prisma LearningObject record naar ons LearningObjectDto
 * (origin = "local")
 */
function mapLocalToDto(localObj: LearningObject, isTeacher: boolean): LearningObjectDto {
  return {
    id: localObj.id,
    uuid: localObj.uuid,
    hruid: localObj.hruid,
    version: localObj.version,
    language: localObj.language,
    title: localObj.title,
    description: localObj.description,
    contentType: localObj.contentType,
    keywords: localObj.keywords,
    targetAges: localObj.targetAges,
    teacherExclusive: localObj.teacherExclusive,
    skosConcepts: localObj.skosConcepts,
    copyright: localObj.copyright,
    licence: localObj.licence,
    difficulty: localObj.difficulty,
    estimatedTime: localObj.estimatedTime,
    available: localObj.available,
    contentLocation: localObj.contentLocation ?? "",
    createdAt: localObj.createdAt.toISOString(),
    updatedAt: localObj.updatedAt.toISOString(),
    origin: "local",
  };
}

/**
 * Haal alle lokale leerobjecten op,
 * filter op teacherExclusive/available als de gebruiker geen teacher is.
 */
export async function getLocalLearningObjects(
  isTeacher: boolean
): Promise<LearningObjectDto[]> {
  const whereClause = isTeacher
    ? {}
    : { teacherExclusive: false, available: true };

  const localObjects = await prisma.learningObject.findMany({
    where: whereClause,
    orderBy: { createdAt: "desc" },
  });

  return localObjects.map((obj) => mapLocalToDto(obj, isTeacher));
}

/**
 * Haal 1 lokaal leerobject op (check of user het mag zien).
 */
export async function getLocalLearningObjectById(
  id: string,
  isTeacher: boolean
): Promise<LearningObjectDto | null> {
  const localObj = await prisma.learningObject.findUnique({ where: { id } });
  if (!localObj) return null;

  if (!isTeacher && (localObj.teacherExclusive || !localObj.available)) {
    return null;
  }
  return mapLocalToDto(localObj, isTeacher);
}

/**
 * Doorzoeken van de lokale DB op basis van searchTerm in de title/description/keywords.
 */
export async function searchLocalLearningObjects(
  isTeacher: boolean,
  searchTerm: string
): Promise<LearningObjectDto[]> {
  const whereClause: any = {
    OR: [
      { title: { contains: searchTerm, mode: "insensitive" } },
      { description: { contains: searchTerm, mode: "insensitive" } },
      { keywords: { has: searchTerm } },
    ],
  };

  if (!isTeacher) {
    whereClause.AND = [{ teacherExclusive: false }, { available: true }];
  }

  const localObjects = await prisma.learningObject.findMany({
    where: whereClause,
    orderBy: { createdAt: "desc" },
  });

  return localObjects.map((obj) => mapLocalToDto(obj, isTeacher));
}

// [NIEUW] Haal lokaal leerobject op via hruid+language+version
export async function getLocalLearningObjectByHruidLangVersion(
  hruid: string,
  language: string,
  version: number,
  isTeacher: boolean
): Promise<LearningObjectDto | null> {
  const localObj = await prisma.learningObject.findUnique({
    

  
     where: {
       hruid,
       language,
       version,
     },
   });

  if (!localObj) return null;

  if (!isTeacher && (localObj.teacherExclusive || !localObj.available)) {
    return null;
  }
  return mapLocalToDto(localObj, isTeacher);
}

=== ./localLearningObjectService.ts ===
import { ContentType, PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export interface LocalLearningObjectData {
  // De data die een teacher kan opgeven bij het aanmaken of updaten
  title: string;
  description: string;
  contentType: ContentType; // bv. "text/markdown", "interactive/quiz", ...
  keywords?: Array<string>; // komma-gescheiden of JSON
  targetAges?: Array<number>; // idem
  teacherExclusive?: boolean;
  skosConcepts?: Array<string>;
  copyright?: string;
  licence?: string;
  difficulty?: number;
  estimatedTime?: number;
  available?: boolean;
  contentLocation?: string;
}

export default class LocalLearningObjectService {
  /**
   * Maakt een nieuw leerobject aan in onze eigen databank.
   * Genereert een UUID voor het veld 'id' (Prisma-model heeft id: String @id).
   */
  static async createLearningObject(
    teacherId: number,
    data: LocalLearningObjectData
  ) {
    // Prisma create
    const newObject = await prisma.learningObject.create({
      data: {
        hruid: `${data.title.toLowerCase()}-${Date.now()}`,
        language: "nl", // Kan ook dynamisch
        title: data.title,
        description: data.description,
        contentType: data.contentType,
        keywords: data.keywords ?? [],
        targetAges: data.targetAges ?? [],
        teacherExclusive: data.teacherExclusive ?? false,
        skosConcepts: data.skosConcepts ?? [],
        copyright: data.copyright ?? "",
        licence: data.licence ?? "CC BY Dwengo",
        difficulty: data.difficulty ?? 1,
        estimatedTime: data.estimatedTime ?? 0,
        available: data.available ?? true,
        contentLocation: data.contentLocation ?? "",
        creatorId: teacherId,
      },
    });

    return newObject;
  }

  /**
   * Geeft alle leerobjecten terug die door een bepaalde teacher zijn aangemaakt.
   * Of (afhankelijk van je wensen) alle leerobjecten in de DB als je dat wilt.
   */
  static async getAllLearningObjectsByTeacher(teacherId: number) {
    const objects = await prisma.learningObject.findMany({
      where: { creatorId: teacherId },
      orderBy: { createdAt: "desc" },
    });
    return objects;
  }

  /**
   * Haalt één leerobject op. Optioneel kun je checken of de aanvrager
   * wel de creator is, als je dat in de controller wilt enforce'n.
   */
  static async getLearningObjectById(id: string) {
    return prisma.learningObject.findUnique({
      where: { id },
    });
  }

  /**
   * Update van een bestaand leerobject. We gaan ervan uit dat je al
   * gecontroleerd hebt of de teacher mag updaten (bv. of teacherId === creatorId).
   */
  static async updateLearningObject(
    id: string,
    data: Partial<LocalLearningObjectData>
  ) {
    // Prisma update
    return prisma.learningObject.update({
      where: { id },
      data: {
        // Als we hruid gelijk stellen aan de titel, dan zal hruid hier ook moeten aangepast worden.

        title: data.title,
        description: data.description,
        contentType: data.contentType,
        keywords: data.keywords,
        targetAges: data.targetAges,
        teacherExclusive: data.teacherExclusive,
        skosConcepts: data.skosConcepts,
        copyright: data.copyright,
        licence: data.licence,
        difficulty: data.difficulty,
        estimatedTime: data.estimatedTime,
        available: data.available,
        contentLocation: data.contentLocation,
      },
    });
  }

  /**
   * Verwijdert een leerobject op basis van zijn id.
   */
  static async deleteLearningObject(id: string) {
    return prisma.learningObject.delete({
      where: { id },
    });
  }
}

=== ./localLearningPathNodeService.ts ===

import { PrismaClient, LearningPathNode } from "@prisma/client";
import localLearningPathService from "./localLearningPathService";
import { dwengoAPI } from "../config/dwengoAPI";

const prisma = new PrismaClient();

/**
 * Data object om een node te maken/updaten.
 */
interface NodeData {
  isExternal: boolean;
  // Voor lokaal:
  localLearningObjectId?: string;

  // Voor Dwengo:
  dwengoHruid?: string;
  dwengoLanguage?: string;
  dwengoVersion?: number;

  // Overige eigenschappen:
  start_node?: boolean;
}

class LocalLearningPathNodeService {
  /**
   * Helper: check of de teacher de eigenaar is van leerpad 'pathId'
   */
  private async checkTeacherOwnsPath(teacherId: number, pathId: string) {
    const path = await prisma.learningPath.findUnique({
      where: { id: pathId },
    });
    if (!path) {
      throw new Error("Leerpad niet gevonden.");
    }
    if (path.creatorId !== teacherId) {
      throw new Error("Je bent niet de eigenaar van dit leerpad.");
    }
  }

  /**
   * Haal alle nodes van dit leerpad op.
   */
  async getAllNodesForPath(
    teacherId: number,
    pathId: string
  ): Promise<LearningPathNode[]> {
    await this.checkTeacherOwnsPath(teacherId, pathId);
    return prisma.learningPathNode.findMany({
      where: { learningPathId: pathId },
      orderBy: { createdAt: "asc" },
    });
  }

  /**
   * Creëer nieuwe node in path. We checken of de referentie klopt (lokale of Dwengo).
   */
  async createNodeForPath(
    teacherId: number,
    pathId: string,
    data: NodeData
  ): Promise<LearningPathNode> {
    await this.checkTeacherOwnsPath(teacherId, pathId);

    // 1) Valideer => afhankelijk van isExternal
    if (data.isExternal) {
      if (
        !data.dwengoHruid ||
        !data.dwengoLanguage ||
        typeof data.dwengoVersion !== "number"
      ) {
        throw new Error(
          "Missing Dwengo-fields: dwengoHruid, dwengoLanguage, dwengoVersion"
        );
      }
      await this.validateDwengoObject(
        data.dwengoHruid,
        data.dwengoLanguage,
        data.dwengoVersion
      );
    } else {
      if (!data.localLearningObjectId) {
        throw new Error("Missing localLearningObjectId for local node");
      }
      await this.validateLocalObject(data.localLearningObjectId);
    }

    // 2) Node maken in DB
    const newNode = await prisma.learningPathNode.create({
      data: {
        learningPathId: pathId,
        isExternal: data.isExternal,

        // Lokale of Dwengo-velden conditioneel
        localLearningObjectId: data.isExternal
          ? undefined
          : data.localLearningObjectId,
        dwengoHruid: data.isExternal ? data.dwengoHruid : undefined,
        dwengoLanguage: data.isExternal ? data.dwengoLanguage : undefined,
        dwengoVersion: data.isExternal ? data.dwengoVersion : undefined,

        start_node: data.start_node ?? false,
      },
    });

    // 3) Aantal nodes bijwerken in leerpad
    await localLearningPathService.updateNumNodes(pathId);

    return newNode;
  }

  /**
   * Update existing node
   */
  async updateNodeForPath(
    teacherId: number,
    pathId: string,
    nodeId: string,
    data: NodeData
  ): Promise<LearningPathNode> {
    await this.checkTeacherOwnsPath(teacherId, pathId);

    const node = await prisma.learningPathNode.findUnique({
      where: { nodeId },
    });
    if (!node) {
      throw new Error("Node niet gevonden.");
    }
    if (node.learningPathId !== pathId) {
      throw new Error("Node hoort niet bij dit leerpad.");
    }

    // Bepaal de nieuwe velden (als de client niet alles meestuurt, fallback naar de bestaande)
    const newIsExternal = data.isExternal ?? node.isExternal;

    let newLocalLearningObjectId = node.localLearningObjectId;
    let newDwengoHruid = node.dwengoHruid;
    let newDwengoLanguage = node.dwengoLanguage;
    let newDwengoVersion = node.dwengoVersion;

    // check of men echt iets aangepast heeft
    if (data.isExternal !== undefined) {
      // men heeft de "extern vs lokaal" toggle aangepast
      if (newIsExternal) {
        // van false => true
        if (
          !data.dwengoHruid ||
          !data.dwengoLanguage ||
          typeof data.dwengoVersion !== "number"
        ) {
          throw new Error(
            "Missing Dwengo fields for external node: hruid, language, version"
          );
        }
        await this.validateDwengoObject(
          data.dwengoHruid,
          data.dwengoLanguage,
          data.dwengoVersion
        );

        // overschrijf
        newDwengoHruid = data.dwengoHruid;
        newDwengoLanguage = data.dwengoLanguage;
        newDwengoVersion = data.dwengoVersion;

        // en wis local
        newLocalLearningObjectId = null;
      } else {
        // van true => false
        if (!data.localLearningObjectId) {
          throw new Error("Missing localLearningObjectId for local node");
        }
        await this.validateLocalObject(data.localLearningObjectId);

        newLocalLearningObjectId = data.localLearningObjectId;
        // wis dwengo
        newDwengoHruid = null;
        newDwengoLanguage = null;
        newDwengoVersion = null;
      }
    } else {
      // isExternal ongewijzigd, maar misschien men geeft nieuwe LORef mee
      if (newIsExternal) {
        const newHruid =
          data.dwengoHruid !== undefined ? data.dwengoHruid : newDwengoHruid;
        const newLang =
          data.dwengoLanguage !== undefined
            ? data.dwengoLanguage
            : newDwengoLanguage;
        const newVer =
          data.dwengoVersion !== undefined
            ? data.dwengoVersion
            : newDwengoVersion;

        if (data.dwengoHruid !== undefined || data.dwengoLanguage !== undefined || data.dwengoVersion !== undefined) {
          // user gaf iets nieuws in Dwengo
          if (!newHruid || !newLang || typeof newVer !== "number") {
            throw new Error("Incomplete Dwengo info");
          }
          await this.validateDwengoObject(newHruid, newLang, newVer);
        }

        newDwengoHruid = newHruid;
        newDwengoLanguage = newLang;
        newDwengoVersion = newVer;
      } else {
        // lokaal node
        if (data.localLearningObjectId !== undefined) {
          // user gaf nieuwe local ID
          await this.validateLocalObject(data.localLearningObjectId);
          newLocalLearningObjectId = data.localLearningObjectId;
        }
      }
    }

    const updatedNode = await prisma.learningPathNode.update({
      where: { nodeId },
      data: {
        isExternal: newIsExternal,
        localLearningObjectId: newIsExternal
          ? null
          : newLocalLearningObjectId ?? null,
        dwengoHruid: newIsExternal ? newDwengoHruid : null,
        dwengoLanguage: newIsExternal ? newDwengoLanguage : null,
        dwengoVersion: newIsExternal ? newDwengoVersion : null,
        start_node: data.start_node ?? node.start_node,
      },
    });

    // Je verandert niet het aantal nodes; geen updateNumNodes nodig
    return updatedNode;
  }

  /**
   * Verwijder node. Update num_nodes nadien.
   */
  async deleteNodeFromPath(
    teacherId: number,
    pathId: string,
    nodeId: string
  ): Promise<void> {
    await this.checkTeacherOwnsPath(teacherId, pathId);

    const node = await prisma.learningPathNode.findUnique({
      where: { nodeId },
    });
    if (!node) {
      throw new Error("Node niet gevonden.");
    }
    if (node.learningPathId !== pathId) {
      throw new Error("Node hoort niet bij dit leerpad.");
    }

    await prisma.learningPathNode.delete({
      where: { nodeId },
    });

    await localLearningPathService.updateNumNodes(pathId);
  }

  /**
   *  ================================
   *  1) Check of local LearningObject bestaat
   *  ================================
   */
  private async validateLocalObject(loId: string): Promise<void> {
    const exists = await prisma.learningObject.findUnique({
      where: { id: loId },
    });
    if (!exists) {
      throw new Error(`Lokaal leerobject '${loId}' niet gevonden.`);
    }
  }

  /**
   *  ================================
   *  2) Check of external Dwengo object bestaat
   *  ================================
   *  Nu met hruid/language/version:
   */
  private async validateDwengoObject(
    hruid: string,
    language: string,
    version: number
  ): Promise<void> {
    try {
      const resp = await dwengoAPI.get(
        `/api/learningObject/getMetadata?hruid=${hruid}&language=${language}&version=${version}`
      );
      if (!resp.data) {
        throw new Error(
          `Dwengo-object (hruid=${hruid}, lang=${language}, ver=${version}) niet gevonden (lege data).`
        );
      }
    } catch (err: any) {
      if (err.response?.status === 404) {
        throw new Error(
          `Dwengo-object (hruid=${hruid}, lang=${language}, ver=${version}) niet gevonden (404).`
        );
      } else {
        console.error(err);
        throw new Error(
          `Fout bij Dwengo-check: ${
            (err.response && err.response.data) || err.message
          }`
        );
      }
    }
  }
}

export default new LocalLearningPathNodeService();

=== ./localLearningPathService.ts ===
import { PrismaClient, LearningPath } from "@prisma/client";

const prisma = new PrismaClient();

export interface LocalLearningPathData {
  title?: string;
  language?: string;
  description?: string;
  image?: string | null;
}

class LocalLearningPathService {
  /**
   * Maak leerpad met num_nodes = 0.
   */
  async createLearningPath(
    teacherId: number,
    data: Required<LocalLearningPathData>
  ): Promise<LearningPath> {
    const newPath = await prisma.learningPath.create({
      data: {
        title: data.title,
        language: data.language,
        description: data.description || "",
        image: data.image,
        num_nodes: 0,
        num_nodes_left: 0,
        creatorId: teacherId,
        // unieker hruid
        hruid: `lp-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
      },
    });
    return newPath;
  }

  async getAllLearningPathsByTeacher(teacherId: number): Promise<LearningPath[]> {
    return prisma.learningPath.findMany({
      where: { creatorId: teacherId },
      orderBy: { createdAt: "desc" },
    });
  }

  async getLearningPathById(pathId: string): Promise<LearningPath | null> {
    return prisma.learningPath.findUnique({
      where: { id: pathId },
    });
  }

  async updateLearningPath(pathId: string, data: LocalLearningPathData): Promise<LearningPath> {
    const updated = await prisma.learningPath.update({
      where: { id: pathId },
      data: {
        title: data.title,
        language: data.language,
        description: data.description,
        image: data.image,
      },
    });
    return updated;
  }

  async deleteLearningPath(pathId: string): Promise<void> {
    await prisma.learningPath.delete({
      where: { id: pathId },
    });
  }

  /**
   * Hulpmethode om bij elke mutatie van nodes het aantal nodes te herberekenen
   */
  async updateNumNodes(pathId: string): Promise<void> {
    const count = await prisma.learningPathNode.count({
      where: { learningPathId: pathId },
    });
    await prisma.learningPath.update({
      where: { id: pathId },
      data: { num_nodes: count },
    });
  }
}

export default new LocalLearningPathService();

=== ./questionsService.ts ===
// src/services/questionsService.ts

import {
  PrismaClient,
  Question,
  QuestionType,
  QuestionSpecific,
  QuestionGeneral,
  QuestionMessage,
} from "@prisma/client";
import  ReferenceValidationService  from "./referenceValidationService";

const prisma = new PrismaClient();

export default class QuestionService {
  /**
   * -----------------------------------------------------
   *  HELPER: Create the base question + initial message
   * -----------------------------------------------------
   */
  private static async createQuestionAndMessage(
    assignmentId: number,
    teamId: number,
    studentId: number,
    title: string,
    text: string,
    type: QuestionType
  ): Promise<Question> {
    // 1) Controleer of assignment en team bestaan
    //    (en dat de studentId in de team zit, e.d.)
    await Promise.all([
      prisma.assignment.findUniqueOrThrow({ where: { id: assignmentId } }),
      prisma.team.findFirstOrThrow({
        where: { id: teamId, students: { some: { userId: studentId } } },
      }),
    ]);

    // 2) Maak question + eerste message in een transactie
    return prisma.$transaction(async (tx) => {
      const question = await tx.question.create({
        data: {
          assignmentId,
          teamId,
          title,
          type,
        },
      });
      await tx.questionMessage.create({
        data: {
          questionId: question.id,
          userId: studentId,
          text,
        },
      });
      return question;
    });
  }

  /**
   * -----------------------------------------------------
   *  CREATE: QUESTION SPECIFIC (leerobject)
   * -----------------------------------------------------
   *  We verwachten in de controller een body met:
   *    assignmentId, title, text, teamId, studentId,
   *    isExternal (bool), 
   *    - Als isExternal=true: dwengoHruid, dwengoLanguage, dwengoVersion
   *    - Als isExternal=false: localLearningObjectId
   *    (optioneel) learningPathId (ter controle dat assignment bij path hoort)
   */
  static async createQuestionSpecific(
    assignmentId: number,
    title: string,
    text: string,
    teamId: number,
    studentId: number,
    type: QuestionType,

    // Belangrijkste velden voor extern / lokaal:
    isExternal: boolean,
    dwengoHruid?: string,
    dwengoLanguage?: string,
    dwengoVersion?: number,
    localLearningObjectId?: string,

    // Als je nog logic hebt om assignment vs path te matchen:
    learningPathId?: string
  ): Promise<QuestionSpecific> {
    // 1) Assignment check
    const assignment = await prisma.assignment.findUnique({
      where: { id: assignmentId },
    });
    if (!assignment) {
      throw new Error("Assignment not found");
    }
    // (optionele check of assignment.pathRef == learningPathId)
    if (learningPathId && assignment.pathRef !== learningPathId) {
      throw new Error("Assignment not linked to this learningPathId");
    }

    // 2) Maak eerst basis question + message
    const question = await this.createQuestionAndMessage(
      assignmentId,
      teamId,
      studentId,
      title,
      text,
      type
    );

    // 3) Valideer object, afhankelijk van isExternal
    //    -> roep ReferenceValidationService aan
    if (isExternal) {
      // Dwengo-leerobject
      if (!dwengoHruid || !dwengoLanguage || typeof dwengoVersion !== "number") {
        throw new Error(
          "Missing Dwengo leerobject fields: dwengoHruid, dwengoLanguage, dwengoVersion"
        );
      }
      await ReferenceValidationService.validateDwengoLearningObject(
        dwengoHruid,
        dwengoLanguage,
        dwengoVersion
      );
    } else {
      // Lokaal
      if (!localLearningObjectId) {
        throw new Error("Missing localLearningObjectId for local object");
      }
      await ReferenceValidationService.validateLocalLearningObject(
        localLearningObjectId
      );
    }

    // 4) questionSpecific aanmaken
    const questionSpec = await prisma.questionSpecific.create({
      data: {
        questionId: question.id,
        isExternal,
        ...(isExternal
          ? {
              dwengoHruid,
              dwengoLanguage,
              dwengoVersion,
            }
          : {
              localLearningObjectId,
            }),
      },
    });

    return questionSpec;
  }

  /**
   * -----------------------------------------------------
   *  CREATE: QUESTION GENERAL (leerpad)
   * -----------------------------------------------------
   *  - local path -> validateLocalLearningPath
   *  - external path -> validateDwengoLearningPath (hruid+language?)
   *  In DB: we slaan 'pathRef' (string) en 'isExternal' op in questionGeneral.
   */
  static async createQuestionGeneral(
    assignmentId: number,
    title: string,
    text: string,
    teamId: number,
    studentId: number,
    type: QuestionType,
    pathRef: string,    // hier komt ofwel localID, ofwel Dwengo-hruid
    isExternal: boolean,
    dwengoLanguage?: string
  ): Promise<QuestionGeneral> {
    // 1) Assignment check
    const assignment = await prisma.assignment.findUnique({
      where: { id: assignmentId },
    });
    if (!assignment) {
      throw new Error("Assignment not found");
    }

    // 2) Basis question + message
    const question = await this.createQuestionAndMessage(
      assignmentId,
      teamId,
      studentId,
      title,
      text,
      type
    );

    // 3) Validatie (dwengo vs local)
    if (isExternal) {
      // We gaan ervan uit dat pathRef = Dwengo-hruid, en dwengoLanguage is meegegeven
      if (!dwengoLanguage) {
        throw new Error("Missing dwengoLanguage for external path");
      }
      await ReferenceValidationService.validateDwengoLearningPath(
        pathRef,
        dwengoLanguage
      );
    } else {
      // Lokale leerpad-check (pathRef = local ID)
      await ReferenceValidationService.validateLocalLearningPath(pathRef);
    }

    // 4) questionGeneral opslaan
    const questionGen = await prisma.questionGeneral.create({
      data: {
        questionId: question.id,
        pathRef: pathRef,   // string
        isExternal: isExternal,
      },
    });

    return questionGen;
  }

  /**
   * -----------------------------------------------------
   *  Overige CREATE, GET, UPDATE, DELETE methodes
   * -----------------------------------------------------
   */

  // Een extra message bij een vraag aanmaken
  static async createQuestionMessage(
    questionId: number,
    text: string,
    userId: number
  ): Promise<QuestionMessage> {
    if (!text || !userId) {
      throw new Error("Invalid input");
    }

    // check of user in het team of teacher van die team
    const question = await prisma.question.findUniqueOrThrow({
      where: { id: questionId },
      include: {
        team: {
          include: {
            students: true,
            class: { include: { ClassTeacher: true } },
          },
        },
      },
    });

    const isUserInTeam = question.team.students.some(
      (student) => student.userId === userId
    );
    const isUserTeacher = question.team.class.ClassTeacher.some(
      (teacher) => teacher.teacherId === userId
    );
    if (!isUserInTeam && !isUserTeacher) {
      throw new Error("User is not in team or not a teacher of this question");
    }

    return prisma.questionMessage.create({
      data: {
        questionId,
        userId,
        text,
      },
    });
  }

  // Titel van een vraag bijwerken
  static async updateQuestion(questionId: number, title: string): Promise<Question> {
    if (!title) {
      throw new Error("Invalid input (title is required)");
    }
    await prisma.question.findUniqueOrThrow({ where: { id: questionId } });
    return prisma.question.update({
      where: { id: questionId },
      data: { title },
    });
  }

  // Een message in een vraag updaten
  static async updateQuestionMessage(
    questionId: number,
    questionMessageId: number,
    text: string,
    userId: number
  ): Promise<QuestionMessage> {
    if (!userId || !text) {
      throw new Error("Invalid input");
    }
    // check of message met (id, questionId, userId) bestaat
    await prisma.questionMessage.findUniqueOrThrow({
      where: {
        // je kunt in Prisma 4.8 nog geen multi-col key direct meegeven,
        // dus doe:
        id: questionMessageId,
      },
    });
    // (optioneel: checken of userId klopt)
    return prisma.questionMessage.update({
      where: { id: questionMessageId },
      data: { text },
    });
  }

  // GET: alle vragen van een team
  static async getQuestionsTeam(teamId: number): Promise<Question[]> {
    await prisma.team.findUniqueOrThrow({ where: { id: teamId } });
    return prisma.question.findMany({
      where: { teamId },
    });
  }

  // GET: alle vragen in een klas
  static async getQuestionsClass(classId: number): Promise<Question[]> {
    await prisma.class.findUniqueOrThrow({ where: { id: classId } });
    return prisma.question.findMany({
      where: { team: { classId } },
    });
  }

  // GET: alle vragen in een assignment en klas
  static async getQuestionsAssignment(
    assignmentId: number,
    classId: number
  ): Promise<Question[]> {
    await prisma.assignment.findUniqueOrThrow({ where: { id: assignmentId } });
    await prisma.class.findUniqueOrThrow({ where: { id: classId } });
    return prisma.question.findMany({
      where: {
        assignmentId,
        team: { classId },
      },
    });
  }

  // GET: één vraag
  static async getQuestion(questionId: number): Promise<Question> {
    return prisma.question.findUniqueOrThrow({ where: { id: questionId } });
  }

  // GET: alle messages in een vraag
  static async getQuestionMessages(questionId: number): Promise<QuestionMessage[]> {
    await prisma.question.findUniqueOrThrow({ where: { id: questionId } });
    return prisma.questionMessage.findMany({ where: { questionId } });
  }

  // DELETE: een vraag
  static async deleteQuestion(questionId: number): Promise<Question> {
    await prisma.question.findUniqueOrThrow({ where: { id: questionId } });
    return prisma.question.delete({ where: { id: questionId } });
  }

  // DELETE: een bericht in een vraag
  static async deleteQuestionMessage(
    questionId: number,
    questionMessageId: number
  ): Promise<QuestionMessage> {
    // optioneel: check of user mag deleten, etc.
    return prisma.questionMessage.delete({
      where: { id: questionMessageId },
    });
  }
}

=== ./referenceValidationService.ts ===
import { PrismaClient } from "@prisma/client";
import { dwengoAPI } from "../config/dwengoAPI";

const prisma = new PrismaClient();

/**
 * ReferenceValidationService:
 *  - Voor LOCAL => check in eigen DB (prisma)
 *  - Voor EXTERN => check bij Dwengo API (met hruid/language/version)
 */
export default class ReferenceValidationService {
  /**
   *  ===========================
   *  LEEROBJECT VALIDATIE
   *  ===========================
   */
  static async validateLocalLearningObject(localId: string): Promise<void> {
    const lo = await prisma.learningObject.findUnique({
      where: { id: localId },
    });
    if (!lo) {
      throw new Error(`Lokaal leerobject '${localId}' niet gevonden.`);
    }
  }

  static async validateDwengoLearningObject(
    hruid: string,
    language: string,
    version: number
  ): Promise<void> {
    // Dwengo: GET /api/learningObject/getMetadata?hruid=xxx&language=xxx&version=xxx
    try {
      const resp = await dwengoAPI.get(
        `/api/learningObject/getMetadata?hruid=${hruid}&language=${language}&version=${version}`
      );
      if (!resp.data) {
        throw new Error(
          `Dwengo leerobject hruid=${hruid},language=${language},version=${version} => geen data ontvangen.`
        );
      }
    } catch (err: any) {
      if (err.response?.status === 404) {
        throw new Error(
          `Dwengo leerobject hruid=${hruid},language=${language},version=${version} niet gevonden (404).`
        );
      }
      throw new Error(`Fout bij Dwengo-check: ${err.message}`);
    }
  }

  /**
   * Als je maar één functie wilt om "either local or external object" te checken,
   * kun je deze wrapper schrijven:
   */
  static async validateLearningObject(
    isExternal: boolean,
    localId?: string,
    hruid?: string,
    language?: string,
    version?: number
  ): Promise<void> {
    if (isExternal) {
      if (!hruid || !language || version == null) {
        throw new Error("Missing Dwengo leerobject referenties (hruid/language/version)");
      }
      await this.validateDwengoLearningObject(hruid, language, version);
    } else {
      if (!localId) {
        throw new Error("Missing localId voor niet-externe leerobjectvalidatie");
      }
      await this.validateLocalLearningObject(localId);
    }
  }

  /**
   *  ===========================
   *  LEERPAD VALIDATIE
   *  ===========================
   */
  static async validateLocalLearningPath(localId: string): Promise<void> {
    const lp = await prisma.learningPath.findUnique({
      where: { id: localId },
    });
    if (!lp) {
      throw new Error(`Lokaal leerpad '${localId}' niet gevonden.`);
    }
  }

  static async validateDwengoLearningPath(hruid: string, language: string): Promise<void> {
    // Dwengo: /api/learningPath/search?hruid=...&language=...
    // (versie voor paden is meestal niet gedefinieerd in Dwengo)
    try {
      const resp = await dwengoAPI.get(
        `/api/learningPath/search?hruid=${hruid}&language=${language}`
      );
      if (!resp.data || !Array.isArray(resp.data) || resp.data.length === 0) {
        throw new Error(
          `Dwengo leerpad (hruid=${hruid}, language=${language}) niet gevonden (lege array).`
        );
      }
      // Eventueel checken of we exact 1 match hebben
    } catch (err: any) {
      throw new Error(`Fout bij Dwengo-check leerpad: ${err.message}`);
    }
  }

  /**
   * Wrapper als je "externe vs lokaal" in één functie wilt:
   */
  static async validateLearningPath(
    isExternal: boolean,
    localId?: string,
    hruid?: string,
    language?: string
  ): Promise<void> {
    if (isExternal) {
      if (!hruid || !language) {
        throw new Error("Missing Dwengo leerpad referenties (hruid/language)");
      }
      await this.validateDwengoLearningPath(hruid, language);
    } else {
      if (!localId) {
        throw new Error("Missing localId voor niet-externe leerpadvalidatie");
      }
      await this.validateLocalLearningPath(localId);
    }
  }
}

=== ./studentAssignmentService.ts ===
import { Assignment, PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

/**
 * Haalt alle assignments op die een student (studentId) kan zien,
 * gesorteerd op meegegeven velden, en limiteer met 'limit'.
 * 
 * Let op: 'pathRef' en 'isExternal' staan nu in Assignment, 
 * we laten ze gewoon meekomen in de resultaten.
 */
export const getAssignmentsForStudent = async (
  studentId: number,
  sortFields: string[],
  order: "asc" | "desc",
  limit: number
): Promise<Assignment[]> => {
  return prisma.assignment.findMany({
    where: {
      classAssignments: {
        some: {
          class: {
            classLinks: {
              some: {
                studentId: studentId,
              },
            },
          },
        },
      },
    },
    orderBy: sortFields.map((field: string) => ({ [field]: order })),
    take: limit,
    // We hebben geen 'learningPath' relation meer, dus geen include needed
  });
};

=== ./studentService.ts ===
import {PrismaClient, Student} from "@prisma/client";

const prisma = new PrismaClient();

export const getStudentsByClass = async (classId: number): Promise<Student[]> => {
    const classWithStudents = await prisma.class.findUnique({
        where: { id: classId },
        include: { classLinks: { include: { student: { include: { user: true } } } } },
    });

    if (!classWithStudents) {
        throw new Error(`Class with ID: ${classId} not found`);
    }

    return classWithStudents.classLinks.map(cs => cs.student);
};


export const getStudentsByTeamAssignment = async (assignmentId: number, teamId: number): Promise<Student[]> => {
    return prisma.student.findMany({
        where: {
            teamAssignments: {
                some: { // Check if the student has any team assignment matching the criteria
                    assignmentId,
                    teamId,
                },
            },
        },
        include: {
            user: true, // Include user info if needed
            teamAssignments: true, // Include the student's team assignments if necessary
        },
    });
};

=== ./teacherServices/teacherAssignmentService.ts ===
// src/services/teacherServices/teacherAssignmentService.ts

import { Assignment, PrismaClient, Role } from "@prisma/client";
import { canUpdateOrDelete, isAuthorized } from "../authorizationService";
import  ReferenceValidationService  from "../../services/referenceValidationService"; 
// ^ let op: named import, géén "default" meer.

const prisma = new PrismaClient();

export default class TeacherAssignmentService {
  /**
   * Creëer een assignment voor een class, met pathRef/isExternal.
   */
  static async createAssignmentForClass(
    teacherId: number,
    classId: number,
    pathRef: string,
    isExternal: boolean,
    deadline: Date
  ): Promise<Assignment> {
    // 1) check authorization
    if (!(await isAuthorized(teacherId, Role.TEACHER, classId))) {
      throw new Error("The teacher is unauthorized to perform this action");
    }

    // 2) Valideer pathRef
    //    => Bij lokaal: check DB; bij extern: check Dwengo via hruid=pathRef
    await ReferenceValidationService.validateLearningPath(isExternal, pathRef);

    // 3) Maak assignment
    return prisma.assignment.create({
      data: {
        pathRef,
        isExternal,
        deadline,
        classAssignments: {
          create: {
            classId,
          },
        },
      },
    });
  }

  /**
   * Haal alle assignments op voor 1 klas
   */
  static async getAssignmentsByClass(
    classId: number,
    teacherId: number
  ): Promise<Assignment[]> {
    if (!(await isAuthorized(teacherId, Role.TEACHER, classId))) {
      throw new Error("The teacher is unauthorized to request the assignments");
    }
    return prisma.assignment.findMany({
      where: {
        classAssignments: {
          some: {
            classId,
          },
        },
      },
    });
  }

  /**
   * Update assignment => pathRef/isExternal
   */
  static async updateAssignment(
    assignmentId: number,
    pathRef: string,
    isExternal: boolean,
    teacherId: number
  ): Promise<Assignment> {
    // 1) autorisatie
    if (!(await canUpdateOrDelete(teacherId, assignmentId))) {
      throw new Error("The teacher is unauthorized to update the assignment");
    }

    // 2) validate new pathRef
    await ReferenceValidationService.validateLearningPath( isExternal,pathRef);

    // 3) update
    return prisma.assignment.update({
      where: { id: assignmentId },
      data: {
        pathRef,
        isExternal,
      },
    });
  }

  /**
   * Delete assignment
   */
  static async deleteAssignment(
    assignmentId: number,
    teacherId: number
  ): Promise<Assignment> {
    if (!(await canUpdateOrDelete(teacherId, assignmentId))) {
      throw new Error("The teacher is unauthorized to delete the assignment");
    }

    return prisma.assignment.delete({
      where: { id: assignmentId },
    });
  }
}

=== ./teacherService.ts ===
import {PrismaClient, Teacher} from "@prisma/client";

const prisma = new PrismaClient();

export const getAllTeachers = async (): Promise<Teacher[]> => {
    return prisma.teacher.findMany({
        include: {
            user: true, // Inclusief gebruikersinformatie
        },
    });
};

export const getTeachersByClass = async (classId: number): Promise<Teacher[]> => {
    return prisma.teacher.findMany({
        where: {
            teaches: {
                some: {classId}, // Find teachers who are linked to this class
            },
        },
        include: {
            user: true // Includes full user data in each teacher object
        },
    });
}


dwengo_backend/index.ts: 

import express, {NextFunction, Request, Response} from "express";
import dotenv from "dotenv";
import errorHandler from "./middleware/errorMiddleware";
import teacherAuthRoutes from "./routes/teacher/teacherAuthRoutes";
import studentAuthRoutes from "./routes/student/studentAuthRoutes";
import learningObjectRoutes from "./routes/learningObject/learningObjectRoutes";
import QuestionRoutes from "./routes/question/questionRoutes";
import learningPathRoutes from "./routes/learningPath/learningPathRoutes";
import teacherLocalLearningObjectRoutes from "./routes/teacher/teacherLocalLearningObjectRoutes";

import assignmentRoutes from "./routes/assignmentRoutes";
import teacherAssignmentRoutes from "./routes/teacher/teacherAssignmentRoutes";
import teacherClassRoutes from "./routes/teacher/teacherClassRoutes";
import studentAssignmentRoutes from "./routes/student/studentAssignmentRoutes";
import feedbackRoutes from "./routes/teacher/feedbackRoutes";
import studentClassRoutes from "./routes/student/studentClassRoutes";
import teacherLocalLearningPathRoutes from "./routes/teacher/teacherLocalLearningPathRoutes";
import teacherLocalLearningPathNodesRoutes from "./routes/teacher/teacherLocalLearningPathNodesRoutes";


import swaggerUi from 'swagger-ui-express';
import YAML from 'yamljs';

dotenv.config();

const app = express();
const swaggerDocument = YAML.load('./openapi3_0.yaml');

// Stel CORS-headers in
app.use((req: Request, res: Response, next: NextFunction) => {
  const allowedOrigins = ["https://dwengo.org", "http://localhost:3000"];
  const origin = req.headers.origin;
  if (origin && allowedOrigins.includes(origin)) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  }
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, DELETE, OPTIONS"
  );
  res.setHeader(
    "Access-Control-Allow-Headers",
    "X-Requested-With, Content-Type, Authorization"
  );
  next();
});

// JSON-parser middleware
app.use(express.json());

// Routes voor Teacher (Classes)
app.use("/teacher/classes", teacherClassRoutes);

// Routes voor student (Classes)
app.use("/student/classes", studentClassRoutes);

// Routes voor Teacher (Auth)
app.use("/teacher/auth", teacherAuthRoutes);
app.use("/teacher/learningObjects", teacherLocalLearningObjectRoutes);
app.use("/teacher/learningPaths", teacherLocalLearningPathRoutes);
app.use("/teacher/learningPaths", teacherLocalLearningPathNodesRoutes)

// Routes voor Student (Auth)
app.use("/student/auth", studentAuthRoutes);

// Routes voor de Assignments
app.use("/assignments", assignmentRoutes);

// Routes voor de aanpassingen op Assignments door teachers
app.use("/teacher/assignments", teacherAssignmentRoutes);
// Routes voor het opvragen van de Assignments door students
app.use("/student/assignments", studentAssignmentRoutes);

app.use('/teacher/feedback', feedbackRoutes);

// Nieuwe routes voor leerobjecten
app.use("/learningObjects", learningObjectRoutes);

app.use("/question", QuestionRoutes);

app.use("/learningPaths", learningPathRoutes);

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

// Error Handler
app.use(errorHandler);


if (process.env.NODE_ENV !== "test") {
  console.log(process.env.NODE_ENV);
  const PORT: string | number = process.env.PORT || 5000;
  app.listen(PORT, () => console.log(`Server draait op poort ${PORT}`));
}

export default app;
